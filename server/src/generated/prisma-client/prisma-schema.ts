// Code generated by Prisma (prisma@1.34.0). DO NOT EDIT.
  // Please don't change this file manually but run `prisma generate` to update it.
  // For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

export const typeDefs = /* GraphQL */ `type AggregateAmenities {
  count: Int!
}

type AggregateBooking {
  count: Int!
}

type AggregateCity {
  count: Int!
}

type AggregateCommune {
  count: Int!
}

type AggregateCountry {
  count: Int!
}

type AggregateCreditCardInformation {
  count: Int!
}

type AggregateHouse {
  count: Int!
}

type AggregateHouse_Favorited {
  count: Int!
}

type AggregateLocation {
  count: Int!
}

type AggregateNegotiation {
  count: Int!
}

type AggregateNotification {
  count: Int!
}

type AggregatePaymentAccount {
  count: Int!
}

type AggregatePaymentHouse {
  count: Int!
}

type AggregatePaymentLanlordInfo {
  count: Int!
}

type AggregatePaypalInformation {
  count: Int!
}

type AggregatePicture {
  count: Int!
}

type AggregatePricing {
  count: Int!
}

type AggregateReview {
  count: Int!
}

type AggregateRoom {
  count: Int!
}

type AggregateState {
  count: Int!
}

type AggregateUser {
  count: Int!
}

type AggregateVideo {
  count: Int!
}

type AggregateViews {
  count: Int!
}

type Amenities {
  id: ID!
  House: House!
  electricity: Boolean!
  electricity_frequency: FREQUENCY
  water_pipe: Boolean!
  water_tank: Boolean!
  water_frequency: FREQUENCY
  elevator: Boolean!
  petsAllowed: Boolean!
  internet: Boolean!
  kitchen: Boolean!
  wirelessInternet: Boolean!
  familyKidFriendly: Boolean!
  freeParkingOnPremises: Boolean!
  hotTub: Boolean!
  pool: Boolean!
  smokingAllowed: Boolean!
  wheelchairAccessible: Boolean!
  cableTv: Boolean!
  suitableForEvents: Boolean!
  dryer: Boolean!
  washer: Boolean!
  indoorFireHouse: Boolean!
  tv: Boolean!
  heating: Boolean!
  hangers: Boolean!
  iron: Boolean!
  hairDryer: Boolean!
  doorman: Boolean!
  paidParkingOffPremises: Boolean!
  freeParkingOnStreet: Boolean!
  gym: Boolean!
  airConditioning: Boolean!
  shampoo: Boolean!
  essentials: Boolean!
  laptopFriendlyWorkspace: Boolean!
  privateEntrance: Boolean!
  buzzerWirelessIntercom: Boolean!
  bathtub: Boolean!
  crib: Boolean!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type AmenitiesConnection {
  pageInfo: PageInfo!
  edges: [AmenitiesEdge]!
  aggregate: AggregateAmenities!
}

input AmenitiesCreateInput {
  id: ID
  House: HouseCreateOneWithoutAmenitiesInput!
  electricity: Boolean
  electricity_frequency: FREQUENCY
  water_pipe: Boolean
  water_tank: Boolean
  water_frequency: FREQUENCY
  elevator: Boolean
  petsAllowed: Boolean
  internet: Boolean
  kitchen: Boolean
  wirelessInternet: Boolean
  familyKidFriendly: Boolean
  freeParkingOnPremises: Boolean
  hotTub: Boolean
  pool: Boolean
  smokingAllowed: Boolean
  wheelchairAccessible: Boolean
  cableTv: Boolean
  suitableForEvents: Boolean
  dryer: Boolean
  washer: Boolean
  indoorFireHouse: Boolean
  tv: Boolean
  heating: Boolean
  hangers: Boolean
  iron: Boolean
  hairDryer: Boolean
  doorman: Boolean
  paidParkingOffPremises: Boolean
  freeParkingOnStreet: Boolean
  gym: Boolean
  airConditioning: Boolean
  shampoo: Boolean
  essentials: Boolean
  laptopFriendlyWorkspace: Boolean
  privateEntrance: Boolean
  buzzerWirelessIntercom: Boolean
  bathtub: Boolean
  crib: Boolean
}

input AmenitiesCreateOneWithoutHouseInput {
  create: AmenitiesCreateWithoutHouseInput
  connect: AmenitiesWhereUniqueInput
}

input AmenitiesCreateWithoutHouseInput {
  id: ID
  electricity: Boolean
  electricity_frequency: FREQUENCY
  water_pipe: Boolean
  water_tank: Boolean
  water_frequency: FREQUENCY
  elevator: Boolean
  petsAllowed: Boolean
  internet: Boolean
  kitchen: Boolean
  wirelessInternet: Boolean
  familyKidFriendly: Boolean
  freeParkingOnPremises: Boolean
  hotTub: Boolean
  pool: Boolean
  smokingAllowed: Boolean
  wheelchairAccessible: Boolean
  cableTv: Boolean
  suitableForEvents: Boolean
  dryer: Boolean
  washer: Boolean
  indoorFireHouse: Boolean
  tv: Boolean
  heating: Boolean
  hangers: Boolean
  iron: Boolean
  hairDryer: Boolean
  doorman: Boolean
  paidParkingOffPremises: Boolean
  freeParkingOnStreet: Boolean
  gym: Boolean
  airConditioning: Boolean
  shampoo: Boolean
  essentials: Boolean
  laptopFriendlyWorkspace: Boolean
  privateEntrance: Boolean
  buzzerWirelessIntercom: Boolean
  bathtub: Boolean
  crib: Boolean
}

type AmenitiesEdge {
  node: Amenities!
  cursor: String!
}

enum AmenitiesOrderByInput {
  id_ASC
  id_DESC
  electricity_ASC
  electricity_DESC
  electricity_frequency_ASC
  electricity_frequency_DESC
  water_pipe_ASC
  water_pipe_DESC
  water_tank_ASC
  water_tank_DESC
  water_frequency_ASC
  water_frequency_DESC
  elevator_ASC
  elevator_DESC
  petsAllowed_ASC
  petsAllowed_DESC
  internet_ASC
  internet_DESC
  kitchen_ASC
  kitchen_DESC
  wirelessInternet_ASC
  wirelessInternet_DESC
  familyKidFriendly_ASC
  familyKidFriendly_DESC
  freeParkingOnPremises_ASC
  freeParkingOnPremises_DESC
  hotTub_ASC
  hotTub_DESC
  pool_ASC
  pool_DESC
  smokingAllowed_ASC
  smokingAllowed_DESC
  wheelchairAccessible_ASC
  wheelchairAccessible_DESC
  cableTv_ASC
  cableTv_DESC
  suitableForEvents_ASC
  suitableForEvents_DESC
  dryer_ASC
  dryer_DESC
  washer_ASC
  washer_DESC
  indoorFireHouse_ASC
  indoorFireHouse_DESC
  tv_ASC
  tv_DESC
  heating_ASC
  heating_DESC
  hangers_ASC
  hangers_DESC
  iron_ASC
  iron_DESC
  hairDryer_ASC
  hairDryer_DESC
  doorman_ASC
  doorman_DESC
  paidParkingOffPremises_ASC
  paidParkingOffPremises_DESC
  freeParkingOnStreet_ASC
  freeParkingOnStreet_DESC
  gym_ASC
  gym_DESC
  airConditioning_ASC
  airConditioning_DESC
  shampoo_ASC
  shampoo_DESC
  essentials_ASC
  essentials_DESC
  laptopFriendlyWorkspace_ASC
  laptopFriendlyWorkspace_DESC
  privateEntrance_ASC
  privateEntrance_DESC
  buzzerWirelessIntercom_ASC
  buzzerWirelessIntercom_DESC
  bathtub_ASC
  bathtub_DESC
  crib_ASC
  crib_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type AmenitiesPreviousValues {
  id: ID!
  electricity: Boolean!
  electricity_frequency: FREQUENCY
  water_pipe: Boolean!
  water_tank: Boolean!
  water_frequency: FREQUENCY
  elevator: Boolean!
  petsAllowed: Boolean!
  internet: Boolean!
  kitchen: Boolean!
  wirelessInternet: Boolean!
  familyKidFriendly: Boolean!
  freeParkingOnPremises: Boolean!
  hotTub: Boolean!
  pool: Boolean!
  smokingAllowed: Boolean!
  wheelchairAccessible: Boolean!
  cableTv: Boolean!
  suitableForEvents: Boolean!
  dryer: Boolean!
  washer: Boolean!
  indoorFireHouse: Boolean!
  tv: Boolean!
  heating: Boolean!
  hangers: Boolean!
  iron: Boolean!
  hairDryer: Boolean!
  doorman: Boolean!
  paidParkingOffPremises: Boolean!
  freeParkingOnStreet: Boolean!
  gym: Boolean!
  airConditioning: Boolean!
  shampoo: Boolean!
  essentials: Boolean!
  laptopFriendlyWorkspace: Boolean!
  privateEntrance: Boolean!
  buzzerWirelessIntercom: Boolean!
  bathtub: Boolean!
  crib: Boolean!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type AmenitiesSubscriptionPayload {
  mutation: MutationType!
  node: Amenities
  updatedFields: [String!]
  previousValues: AmenitiesPreviousValues
}

input AmenitiesSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: AmenitiesWhereInput
  AND: [AmenitiesSubscriptionWhereInput!]
  OR: [AmenitiesSubscriptionWhereInput!]
  NOT: [AmenitiesSubscriptionWhereInput!]
}

input AmenitiesUpdateInput {
  House: HouseUpdateOneRequiredWithoutAmenitiesInput
  electricity: Boolean
  electricity_frequency: FREQUENCY
  water_pipe: Boolean
  water_tank: Boolean
  water_frequency: FREQUENCY
  elevator: Boolean
  petsAllowed: Boolean
  internet: Boolean
  kitchen: Boolean
  wirelessInternet: Boolean
  familyKidFriendly: Boolean
  freeParkingOnPremises: Boolean
  hotTub: Boolean
  pool: Boolean
  smokingAllowed: Boolean
  wheelchairAccessible: Boolean
  cableTv: Boolean
  suitableForEvents: Boolean
  dryer: Boolean
  washer: Boolean
  indoorFireHouse: Boolean
  tv: Boolean
  heating: Boolean
  hangers: Boolean
  iron: Boolean
  hairDryer: Boolean
  doorman: Boolean
  paidParkingOffPremises: Boolean
  freeParkingOnStreet: Boolean
  gym: Boolean
  airConditioning: Boolean
  shampoo: Boolean
  essentials: Boolean
  laptopFriendlyWorkspace: Boolean
  privateEntrance: Boolean
  buzzerWirelessIntercom: Boolean
  bathtub: Boolean
  crib: Boolean
}

input AmenitiesUpdateManyMutationInput {
  electricity: Boolean
  electricity_frequency: FREQUENCY
  water_pipe: Boolean
  water_tank: Boolean
  water_frequency: FREQUENCY
  elevator: Boolean
  petsAllowed: Boolean
  internet: Boolean
  kitchen: Boolean
  wirelessInternet: Boolean
  familyKidFriendly: Boolean
  freeParkingOnPremises: Boolean
  hotTub: Boolean
  pool: Boolean
  smokingAllowed: Boolean
  wheelchairAccessible: Boolean
  cableTv: Boolean
  suitableForEvents: Boolean
  dryer: Boolean
  washer: Boolean
  indoorFireHouse: Boolean
  tv: Boolean
  heating: Boolean
  hangers: Boolean
  iron: Boolean
  hairDryer: Boolean
  doorman: Boolean
  paidParkingOffPremises: Boolean
  freeParkingOnStreet: Boolean
  gym: Boolean
  airConditioning: Boolean
  shampoo: Boolean
  essentials: Boolean
  laptopFriendlyWorkspace: Boolean
  privateEntrance: Boolean
  buzzerWirelessIntercom: Boolean
  bathtub: Boolean
  crib: Boolean
}

input AmenitiesUpdateOneRequiredWithoutHouseInput {
  create: AmenitiesCreateWithoutHouseInput
  update: AmenitiesUpdateWithoutHouseDataInput
  upsert: AmenitiesUpsertWithoutHouseInput
  connect: AmenitiesWhereUniqueInput
}

input AmenitiesUpdateWithoutHouseDataInput {
  electricity: Boolean
  electricity_frequency: FREQUENCY
  water_pipe: Boolean
  water_tank: Boolean
  water_frequency: FREQUENCY
  elevator: Boolean
  petsAllowed: Boolean
  internet: Boolean
  kitchen: Boolean
  wirelessInternet: Boolean
  familyKidFriendly: Boolean
  freeParkingOnPremises: Boolean
  hotTub: Boolean
  pool: Boolean
  smokingAllowed: Boolean
  wheelchairAccessible: Boolean
  cableTv: Boolean
  suitableForEvents: Boolean
  dryer: Boolean
  washer: Boolean
  indoorFireHouse: Boolean
  tv: Boolean
  heating: Boolean
  hangers: Boolean
  iron: Boolean
  hairDryer: Boolean
  doorman: Boolean
  paidParkingOffPremises: Boolean
  freeParkingOnStreet: Boolean
  gym: Boolean
  airConditioning: Boolean
  shampoo: Boolean
  essentials: Boolean
  laptopFriendlyWorkspace: Boolean
  privateEntrance: Boolean
  buzzerWirelessIntercom: Boolean
  bathtub: Boolean
  crib: Boolean
}

input AmenitiesUpsertWithoutHouseInput {
  update: AmenitiesUpdateWithoutHouseDataInput!
  create: AmenitiesCreateWithoutHouseInput!
}

input AmenitiesWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  House: HouseWhereInput
  electricity: Boolean
  electricity_not: Boolean
  electricity_frequency: FREQUENCY
  electricity_frequency_not: FREQUENCY
  electricity_frequency_in: [FREQUENCY!]
  electricity_frequency_not_in: [FREQUENCY!]
  water_pipe: Boolean
  water_pipe_not: Boolean
  water_tank: Boolean
  water_tank_not: Boolean
  water_frequency: FREQUENCY
  water_frequency_not: FREQUENCY
  water_frequency_in: [FREQUENCY!]
  water_frequency_not_in: [FREQUENCY!]
  elevator: Boolean
  elevator_not: Boolean
  petsAllowed: Boolean
  petsAllowed_not: Boolean
  internet: Boolean
  internet_not: Boolean
  kitchen: Boolean
  kitchen_not: Boolean
  wirelessInternet: Boolean
  wirelessInternet_not: Boolean
  familyKidFriendly: Boolean
  familyKidFriendly_not: Boolean
  freeParkingOnPremises: Boolean
  freeParkingOnPremises_not: Boolean
  hotTub: Boolean
  hotTub_not: Boolean
  pool: Boolean
  pool_not: Boolean
  smokingAllowed: Boolean
  smokingAllowed_not: Boolean
  wheelchairAccessible: Boolean
  wheelchairAccessible_not: Boolean
  cableTv: Boolean
  cableTv_not: Boolean
  suitableForEvents: Boolean
  suitableForEvents_not: Boolean
  dryer: Boolean
  dryer_not: Boolean
  washer: Boolean
  washer_not: Boolean
  indoorFireHouse: Boolean
  indoorFireHouse_not: Boolean
  tv: Boolean
  tv_not: Boolean
  heating: Boolean
  heating_not: Boolean
  hangers: Boolean
  hangers_not: Boolean
  iron: Boolean
  iron_not: Boolean
  hairDryer: Boolean
  hairDryer_not: Boolean
  doorman: Boolean
  doorman_not: Boolean
  paidParkingOffPremises: Boolean
  paidParkingOffPremises_not: Boolean
  freeParkingOnStreet: Boolean
  freeParkingOnStreet_not: Boolean
  gym: Boolean
  gym_not: Boolean
  airConditioning: Boolean
  airConditioning_not: Boolean
  shampoo: Boolean
  shampoo_not: Boolean
  essentials: Boolean
  essentials_not: Boolean
  laptopFriendlyWorkspace: Boolean
  laptopFriendlyWorkspace_not: Boolean
  privateEntrance: Boolean
  privateEntrance_not: Boolean
  buzzerWirelessIntercom: Boolean
  buzzerWirelessIntercom_not: Boolean
  bathtub: Boolean
  bathtub_not: Boolean
  crib: Boolean
  crib_not: Boolean
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [AmenitiesWhereInput!]
  OR: [AmenitiesWhereInput!]
  NOT: [AmenitiesWhereInput!]
}

input AmenitiesWhereUniqueInput {
  id: ID
}

type BatchPayload {
  count: Long!
}

type Booking {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  bookee: User!
  House: House!
  startDate: DateTime!
  endDate: DateTime!
  payment: PaymentHouse!
}

type BookingConnection {
  pageInfo: PageInfo!
  edges: [BookingEdge]!
  aggregate: AggregateBooking!
}

input BookingCreateInput {
  id: ID
  bookee: UserCreateOneWithoutBookingsInput!
  House: HouseCreateOneWithoutBookingsInput!
  startDate: DateTime!
  endDate: DateTime!
  payment: PaymentHouseCreateOneWithoutBookingInput!
}

input BookingCreateManyWithoutBookeeInput {
  create: [BookingCreateWithoutBookeeInput!]
  connect: [BookingWhereUniqueInput!]
}

input BookingCreateManyWithoutHouseInput {
  create: [BookingCreateWithoutHouseInput!]
  connect: [BookingWhereUniqueInput!]
}

input BookingCreateOneWithoutPaymentInput {
  create: BookingCreateWithoutPaymentInput
  connect: BookingWhereUniqueInput
}

input BookingCreateWithoutBookeeInput {
  id: ID
  House: HouseCreateOneWithoutBookingsInput!
  startDate: DateTime!
  endDate: DateTime!
  payment: PaymentHouseCreateOneWithoutBookingInput!
}

input BookingCreateWithoutHouseInput {
  id: ID
  bookee: UserCreateOneWithoutBookingsInput!
  startDate: DateTime!
  endDate: DateTime!
  payment: PaymentHouseCreateOneWithoutBookingInput!
}

input BookingCreateWithoutPaymentInput {
  id: ID
  bookee: UserCreateOneWithoutBookingsInput!
  House: HouseCreateOneWithoutBookingsInput!
  startDate: DateTime!
  endDate: DateTime!
}

type BookingEdge {
  node: Booking!
  cursor: String!
}

enum BookingOrderByInput {
  id_ASC
  id_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
  startDate_ASC
  startDate_DESC
  endDate_ASC
  endDate_DESC
}

type BookingPreviousValues {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  startDate: DateTime!
  endDate: DateTime!
}

input BookingScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  startDate: DateTime
  startDate_not: DateTime
  startDate_in: [DateTime!]
  startDate_not_in: [DateTime!]
  startDate_lt: DateTime
  startDate_lte: DateTime
  startDate_gt: DateTime
  startDate_gte: DateTime
  endDate: DateTime
  endDate_not: DateTime
  endDate_in: [DateTime!]
  endDate_not_in: [DateTime!]
  endDate_lt: DateTime
  endDate_lte: DateTime
  endDate_gt: DateTime
  endDate_gte: DateTime
  AND: [BookingScalarWhereInput!]
  OR: [BookingScalarWhereInput!]
  NOT: [BookingScalarWhereInput!]
}

type BookingSubscriptionPayload {
  mutation: MutationType!
  node: Booking
  updatedFields: [String!]
  previousValues: BookingPreviousValues
}

input BookingSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: BookingWhereInput
  AND: [BookingSubscriptionWhereInput!]
  OR: [BookingSubscriptionWhereInput!]
  NOT: [BookingSubscriptionWhereInput!]
}

input BookingUpdateInput {
  bookee: UserUpdateOneRequiredWithoutBookingsInput
  House: HouseUpdateOneRequiredWithoutBookingsInput
  startDate: DateTime
  endDate: DateTime
  payment: PaymentHouseUpdateOneRequiredWithoutBookingInput
}

input BookingUpdateManyDataInput {
  startDate: DateTime
  endDate: DateTime
}

input BookingUpdateManyMutationInput {
  startDate: DateTime
  endDate: DateTime
}

input BookingUpdateManyWithoutBookeeInput {
  create: [BookingCreateWithoutBookeeInput!]
  delete: [BookingWhereUniqueInput!]
  connect: [BookingWhereUniqueInput!]
  set: [BookingWhereUniqueInput!]
  disconnect: [BookingWhereUniqueInput!]
  update: [BookingUpdateWithWhereUniqueWithoutBookeeInput!]
  upsert: [BookingUpsertWithWhereUniqueWithoutBookeeInput!]
  deleteMany: [BookingScalarWhereInput!]
  updateMany: [BookingUpdateManyWithWhereNestedInput!]
}

input BookingUpdateManyWithoutHouseInput {
  create: [BookingCreateWithoutHouseInput!]
  delete: [BookingWhereUniqueInput!]
  connect: [BookingWhereUniqueInput!]
  set: [BookingWhereUniqueInput!]
  disconnect: [BookingWhereUniqueInput!]
  update: [BookingUpdateWithWhereUniqueWithoutHouseInput!]
  upsert: [BookingUpsertWithWhereUniqueWithoutHouseInput!]
  deleteMany: [BookingScalarWhereInput!]
  updateMany: [BookingUpdateManyWithWhereNestedInput!]
}

input BookingUpdateManyWithWhereNestedInput {
  where: BookingScalarWhereInput!
  data: BookingUpdateManyDataInput!
}

input BookingUpdateOneRequiredWithoutPaymentInput {
  create: BookingCreateWithoutPaymentInput
  update: BookingUpdateWithoutPaymentDataInput
  upsert: BookingUpsertWithoutPaymentInput
  connect: BookingWhereUniqueInput
}

input BookingUpdateWithoutBookeeDataInput {
  House: HouseUpdateOneRequiredWithoutBookingsInput
  startDate: DateTime
  endDate: DateTime
  payment: PaymentHouseUpdateOneRequiredWithoutBookingInput
}

input BookingUpdateWithoutHouseDataInput {
  bookee: UserUpdateOneRequiredWithoutBookingsInput
  startDate: DateTime
  endDate: DateTime
  payment: PaymentHouseUpdateOneRequiredWithoutBookingInput
}

input BookingUpdateWithoutPaymentDataInput {
  bookee: UserUpdateOneRequiredWithoutBookingsInput
  House: HouseUpdateOneRequiredWithoutBookingsInput
  startDate: DateTime
  endDate: DateTime
}

input BookingUpdateWithWhereUniqueWithoutBookeeInput {
  where: BookingWhereUniqueInput!
  data: BookingUpdateWithoutBookeeDataInput!
}

input BookingUpdateWithWhereUniqueWithoutHouseInput {
  where: BookingWhereUniqueInput!
  data: BookingUpdateWithoutHouseDataInput!
}

input BookingUpsertWithoutPaymentInput {
  update: BookingUpdateWithoutPaymentDataInput!
  create: BookingCreateWithoutPaymentInput!
}

input BookingUpsertWithWhereUniqueWithoutBookeeInput {
  where: BookingWhereUniqueInput!
  update: BookingUpdateWithoutBookeeDataInput!
  create: BookingCreateWithoutBookeeInput!
}

input BookingUpsertWithWhereUniqueWithoutHouseInput {
  where: BookingWhereUniqueInput!
  update: BookingUpdateWithoutHouseDataInput!
  create: BookingCreateWithoutHouseInput!
}

input BookingWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  bookee: UserWhereInput
  House: HouseWhereInput
  startDate: DateTime
  startDate_not: DateTime
  startDate_in: [DateTime!]
  startDate_not_in: [DateTime!]
  startDate_lt: DateTime
  startDate_lte: DateTime
  startDate_gt: DateTime
  startDate_gte: DateTime
  endDate: DateTime
  endDate_not: DateTime
  endDate_in: [DateTime!]
  endDate_not_in: [DateTime!]
  endDate_lt: DateTime
  endDate_lte: DateTime
  endDate_gt: DateTime
  endDate_gte: DateTime
  payment: PaymentHouseWhereInput
  AND: [BookingWhereInput!]
  OR: [BookingWhereInput!]
  NOT: [BookingWhereInput!]
}

input BookingWhereUniqueInput {
  id: ID
}

type City {
  id: ID!
  name: String!
  rank: Int
  state: State!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type CityConnection {
  pageInfo: PageInfo!
  edges: [CityEdge]!
  aggregate: AggregateCity!
}

input CityCreateInput {
  id: ID
  name: String!
  rank: Int
  state: StateCreateOneInput!
}

input CityCreateOneInput {
  create: CityCreateInput
  connect: CityWhereUniqueInput
}

type CityEdge {
  node: City!
  cursor: String!
}

enum CityOrderByInput {
  id_ASC
  id_DESC
  name_ASC
  name_DESC
  rank_ASC
  rank_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type CityPreviousValues {
  id: ID!
  name: String!
  rank: Int
  createdAt: DateTime!
  updatedAt: DateTime!
}

type CitySubscriptionPayload {
  mutation: MutationType!
  node: City
  updatedFields: [String!]
  previousValues: CityPreviousValues
}

input CitySubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: CityWhereInput
  AND: [CitySubscriptionWhereInput!]
  OR: [CitySubscriptionWhereInput!]
  NOT: [CitySubscriptionWhereInput!]
}

input CityUpdateDataInput {
  name: String
  rank: Int
  state: StateUpdateOneRequiredInput
}

input CityUpdateInput {
  name: String
  rank: Int
  state: StateUpdateOneRequiredInput
}

input CityUpdateManyMutationInput {
  name: String
  rank: Int
}

input CityUpdateOneRequiredInput {
  create: CityCreateInput
  update: CityUpdateDataInput
  upsert: CityUpsertNestedInput
  connect: CityWhereUniqueInput
}

input CityUpsertNestedInput {
  update: CityUpdateDataInput!
  create: CityCreateInput!
}

input CityWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  rank: Int
  rank_not: Int
  rank_in: [Int!]
  rank_not_in: [Int!]
  rank_lt: Int
  rank_lte: Int
  rank_gt: Int
  rank_gte: Int
  state: StateWhereInput
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [CityWhereInput!]
  OR: [CityWhereInput!]
  NOT: [CityWhereInput!]
}

input CityWhereUniqueInput {
  id: ID
}

type Commune {
  id: ID!
  name: String!
  rank: Int
  city: City!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type CommuneConnection {
  pageInfo: PageInfo!
  edges: [CommuneEdge]!
  aggregate: AggregateCommune!
}

input CommuneCreateInput {
  id: ID
  name: String!
  rank: Int
  city: CityCreateOneInput!
}

input CommuneCreateOneInput {
  create: CommuneCreateInput
  connect: CommuneWhereUniqueInput
}

type CommuneEdge {
  node: Commune!
  cursor: String!
}

enum CommuneOrderByInput {
  id_ASC
  id_DESC
  name_ASC
  name_DESC
  rank_ASC
  rank_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type CommunePreviousValues {
  id: ID!
  name: String!
  rank: Int
  createdAt: DateTime!
  updatedAt: DateTime!
}

type CommuneSubscriptionPayload {
  mutation: MutationType!
  node: Commune
  updatedFields: [String!]
  previousValues: CommunePreviousValues
}

input CommuneSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: CommuneWhereInput
  AND: [CommuneSubscriptionWhereInput!]
  OR: [CommuneSubscriptionWhereInput!]
  NOT: [CommuneSubscriptionWhereInput!]
}

input CommuneUpdateDataInput {
  name: String
  rank: Int
  city: CityUpdateOneRequiredInput
}

input CommuneUpdateInput {
  name: String
  rank: Int
  city: CityUpdateOneRequiredInput
}

input CommuneUpdateManyMutationInput {
  name: String
  rank: Int
}

input CommuneUpdateOneInput {
  create: CommuneCreateInput
  update: CommuneUpdateDataInput
  upsert: CommuneUpsertNestedInput
  delete: Boolean
  disconnect: Boolean
  connect: CommuneWhereUniqueInput
}

input CommuneUpsertNestedInput {
  update: CommuneUpdateDataInput!
  create: CommuneCreateInput!
}

input CommuneWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  rank: Int
  rank_not: Int
  rank_in: [Int!]
  rank_not_in: [Int!]
  rank_lt: Int
  rank_lte: Int
  rank_gt: Int
  rank_gte: Int
  city: CityWhereInput
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [CommuneWhereInput!]
  OR: [CommuneWhereInput!]
  NOT: [CommuneWhereInput!]
}

input CommuneWhereUniqueInput {
  id: ID
}

type Country {
  id: ID!
  name: String!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type CountryConnection {
  pageInfo: PageInfo!
  edges: [CountryEdge]!
  aggregate: AggregateCountry!
}

input CountryCreateInput {
  id: ID
  name: String!
}

input CountryCreateOneInput {
  create: CountryCreateInput
  connect: CountryWhereUniqueInput
}

type CountryEdge {
  node: Country!
  cursor: String!
}

enum CountryOrderByInput {
  id_ASC
  id_DESC
  name_ASC
  name_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type CountryPreviousValues {
  id: ID!
  name: String!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type CountrySubscriptionPayload {
  mutation: MutationType!
  node: Country
  updatedFields: [String!]
  previousValues: CountryPreviousValues
}

input CountrySubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: CountryWhereInput
  AND: [CountrySubscriptionWhereInput!]
  OR: [CountrySubscriptionWhereInput!]
  NOT: [CountrySubscriptionWhereInput!]
}

input CountryUpdateDataInput {
  name: String
}

input CountryUpdateInput {
  name: String
}

input CountryUpdateManyMutationInput {
  name: String
}

input CountryUpdateOneRequiredInput {
  create: CountryCreateInput
  update: CountryUpdateDataInput
  upsert: CountryUpsertNestedInput
  connect: CountryWhereUniqueInput
}

input CountryUpsertNestedInput {
  update: CountryUpdateDataInput!
  create: CountryCreateInput!
}

input CountryWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [CountryWhereInput!]
  OR: [CountryWhereInput!]
  NOT: [CountryWhereInput!]
}

input CountryWhereUniqueInput {
  id: ID
}

type CreditCardInformation {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  cardNumber: String!
  expiresOnMonth: Int!
  expiresOnYear: Int!
  securityCode: String!
  firstName: String!
  lastName: String!
  postalCode: String!
  country: String!
  paymentAccount: PaymentAccount
}

type CreditCardInformationConnection {
  pageInfo: PageInfo!
  edges: [CreditCardInformationEdge]!
  aggregate: AggregateCreditCardInformation!
}

input CreditCardInformationCreateInput {
  id: ID
  cardNumber: String!
  expiresOnMonth: Int!
  expiresOnYear: Int!
  securityCode: String!
  firstName: String!
  lastName: String!
  postalCode: String!
  country: String!
  paymentAccount: PaymentAccountCreateOneWithoutCreditcardInput
}

input CreditCardInformationCreateOneWithoutPaymentAccountInput {
  create: CreditCardInformationCreateWithoutPaymentAccountInput
  connect: CreditCardInformationWhereUniqueInput
}

input CreditCardInformationCreateWithoutPaymentAccountInput {
  id: ID
  cardNumber: String!
  expiresOnMonth: Int!
  expiresOnYear: Int!
  securityCode: String!
  firstName: String!
  lastName: String!
  postalCode: String!
  country: String!
}

type CreditCardInformationEdge {
  node: CreditCardInformation!
  cursor: String!
}

enum CreditCardInformationOrderByInput {
  id_ASC
  id_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
  cardNumber_ASC
  cardNumber_DESC
  expiresOnMonth_ASC
  expiresOnMonth_DESC
  expiresOnYear_ASC
  expiresOnYear_DESC
  securityCode_ASC
  securityCode_DESC
  firstName_ASC
  firstName_DESC
  lastName_ASC
  lastName_DESC
  postalCode_ASC
  postalCode_DESC
  country_ASC
  country_DESC
}

type CreditCardInformationPreviousValues {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  cardNumber: String!
  expiresOnMonth: Int!
  expiresOnYear: Int!
  securityCode: String!
  firstName: String!
  lastName: String!
  postalCode: String!
  country: String!
}

type CreditCardInformationSubscriptionPayload {
  mutation: MutationType!
  node: CreditCardInformation
  updatedFields: [String!]
  previousValues: CreditCardInformationPreviousValues
}

input CreditCardInformationSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: CreditCardInformationWhereInput
  AND: [CreditCardInformationSubscriptionWhereInput!]
  OR: [CreditCardInformationSubscriptionWhereInput!]
  NOT: [CreditCardInformationSubscriptionWhereInput!]
}

input CreditCardInformationUpdateInput {
  cardNumber: String
  expiresOnMonth: Int
  expiresOnYear: Int
  securityCode: String
  firstName: String
  lastName: String
  postalCode: String
  country: String
  paymentAccount: PaymentAccountUpdateOneWithoutCreditcardInput
}

input CreditCardInformationUpdateManyMutationInput {
  cardNumber: String
  expiresOnMonth: Int
  expiresOnYear: Int
  securityCode: String
  firstName: String
  lastName: String
  postalCode: String
  country: String
}

input CreditCardInformationUpdateOneWithoutPaymentAccountInput {
  create: CreditCardInformationCreateWithoutPaymentAccountInput
  update: CreditCardInformationUpdateWithoutPaymentAccountDataInput
  upsert: CreditCardInformationUpsertWithoutPaymentAccountInput
  delete: Boolean
  disconnect: Boolean
  connect: CreditCardInformationWhereUniqueInput
}

input CreditCardInformationUpdateWithoutPaymentAccountDataInput {
  cardNumber: String
  expiresOnMonth: Int
  expiresOnYear: Int
  securityCode: String
  firstName: String
  lastName: String
  postalCode: String
  country: String
}

input CreditCardInformationUpsertWithoutPaymentAccountInput {
  update: CreditCardInformationUpdateWithoutPaymentAccountDataInput!
  create: CreditCardInformationCreateWithoutPaymentAccountInput!
}

input CreditCardInformationWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  cardNumber: String
  cardNumber_not: String
  cardNumber_in: [String!]
  cardNumber_not_in: [String!]
  cardNumber_lt: String
  cardNumber_lte: String
  cardNumber_gt: String
  cardNumber_gte: String
  cardNumber_contains: String
  cardNumber_not_contains: String
  cardNumber_starts_with: String
  cardNumber_not_starts_with: String
  cardNumber_ends_with: String
  cardNumber_not_ends_with: String
  expiresOnMonth: Int
  expiresOnMonth_not: Int
  expiresOnMonth_in: [Int!]
  expiresOnMonth_not_in: [Int!]
  expiresOnMonth_lt: Int
  expiresOnMonth_lte: Int
  expiresOnMonth_gt: Int
  expiresOnMonth_gte: Int
  expiresOnYear: Int
  expiresOnYear_not: Int
  expiresOnYear_in: [Int!]
  expiresOnYear_not_in: [Int!]
  expiresOnYear_lt: Int
  expiresOnYear_lte: Int
  expiresOnYear_gt: Int
  expiresOnYear_gte: Int
  securityCode: String
  securityCode_not: String
  securityCode_in: [String!]
  securityCode_not_in: [String!]
  securityCode_lt: String
  securityCode_lte: String
  securityCode_gt: String
  securityCode_gte: String
  securityCode_contains: String
  securityCode_not_contains: String
  securityCode_starts_with: String
  securityCode_not_starts_with: String
  securityCode_ends_with: String
  securityCode_not_ends_with: String
  firstName: String
  firstName_not: String
  firstName_in: [String!]
  firstName_not_in: [String!]
  firstName_lt: String
  firstName_lte: String
  firstName_gt: String
  firstName_gte: String
  firstName_contains: String
  firstName_not_contains: String
  firstName_starts_with: String
  firstName_not_starts_with: String
  firstName_ends_with: String
  firstName_not_ends_with: String
  lastName: String
  lastName_not: String
  lastName_in: [String!]
  lastName_not_in: [String!]
  lastName_lt: String
  lastName_lte: String
  lastName_gt: String
  lastName_gte: String
  lastName_contains: String
  lastName_not_contains: String
  lastName_starts_with: String
  lastName_not_starts_with: String
  lastName_ends_with: String
  lastName_not_ends_with: String
  postalCode: String
  postalCode_not: String
  postalCode_in: [String!]
  postalCode_not_in: [String!]
  postalCode_lt: String
  postalCode_lte: String
  postalCode_gt: String
  postalCode_gte: String
  postalCode_contains: String
  postalCode_not_contains: String
  postalCode_starts_with: String
  postalCode_not_starts_with: String
  postalCode_ends_with: String
  postalCode_not_ends_with: String
  country: String
  country_not: String
  country_in: [String!]
  country_not_in: [String!]
  country_lt: String
  country_lte: String
  country_gt: String
  country_gte: String
  country_contains: String
  country_not_contains: String
  country_starts_with: String
  country_not_starts_with: String
  country_ends_with: String
  country_not_ends_with: String
  paymentAccount: PaymentAccountWhereInput
  AND: [CreditCardInformationWhereInput!]
  OR: [CreditCardInformationWhereInput!]
  NOT: [CreditCardInformationWhereInput!]
}

input CreditCardInformationWhereUniqueInput {
  id: ID
}

enum CURRENCY {
  HTG
  USD
}

scalar DateTime

enum FREQUENCY {
  NEVER
  SOMETIMES
  OFTEN
  ALWAYS
}

type House {
  id: ID!
  area: Int
  age: Int
  shortDescription: String
  description: String
  maxGuests: Int!
  numBedrooms: Int!
  numBaths: Int!
  numLivingrooms: Int
  numDiningrooms: Int
  reviews(where: ReviewWhereInput, orderBy: ReviewOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Review!]
  amenities: Amenities!
  host: User!
  pricing: Pricing!
  location: Location!
  leaseType: HOUSE_LEASE_TYPE
  verified: Boolean!
  type: HOUSE_TYPES
  residency: House_RESIDENCY
  lease: Int!
  rooms(where: RoomWhereInput, orderBy: RoomOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Room!]
  views: Views
  bookings(where: BookingWhereInput, orderBy: BookingOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Booking!]
  contactInfoPayments(where: PaymentLanlordInfoWhereInput, orderBy: PaymentLanlordInfoOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [PaymentLanlordInfo!]
  popularity: Int!
  preview_image: Picture
  createdAt: DateTime!
  updatedAt: DateTime!
}

type House_Favorited {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  user: User!
  house: House!
}

type House_FavoritedConnection {
  pageInfo: PageInfo!
  edges: [House_FavoritedEdge]!
  aggregate: AggregateHouse_Favorited!
}

input House_FavoritedCreateInput {
  id: ID
  user: UserCreateOneInput!
  house: HouseCreateOneInput!
}

type House_FavoritedEdge {
  node: House_Favorited!
  cursor: String!
}

enum House_FavoritedOrderByInput {
  id_ASC
  id_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type House_FavoritedPreviousValues {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type House_FavoritedSubscriptionPayload {
  mutation: MutationType!
  node: House_Favorited
  updatedFields: [String!]
  previousValues: House_FavoritedPreviousValues
}

input House_FavoritedSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: House_FavoritedWhereInput
  AND: [House_FavoritedSubscriptionWhereInput!]
  OR: [House_FavoritedSubscriptionWhereInput!]
  NOT: [House_FavoritedSubscriptionWhereInput!]
}

input House_FavoritedUpdateInput {
  user: UserUpdateOneRequiredInput
  house: HouseUpdateOneRequiredInput
}

input House_FavoritedWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  user: UserWhereInput
  house: HouseWhereInput
  AND: [House_FavoritedWhereInput!]
  OR: [House_FavoritedWhereInput!]
  NOT: [House_FavoritedWhereInput!]
}

input House_FavoritedWhereUniqueInput {
  id: ID
}

enum HOUSE_LEASE_TYPE {
  WEEKLY
  MONTHLY
  YEARLY
}

enum House_RESIDENCY {
  BUSINESS
  RESIDENCE
}

enum HOUSE_TYPES {
  APARTMENT
  VILLA
  STUDIO
}

type HouseConnection {
  pageInfo: PageInfo!
  edges: [HouseEdge]!
  aggregate: AggregateHouse!
}

input HouseCreateInput {
  id: ID
  area: Int
  age: Int
  shortDescription: String
  description: String
  maxGuests: Int!
  numBedrooms: Int!
  numBaths: Int!
  numLivingrooms: Int
  numDiningrooms: Int
  reviews: ReviewCreateManyWithoutHouseInput
  amenities: AmenitiesCreateOneWithoutHouseInput!
  host: UserCreateOneWithoutOwnedHousesInput!
  pricing: PricingCreateOneWithoutHouseInput!
  location: LocationCreateOneInput!
  leaseType: HOUSE_LEASE_TYPE
  verified: Boolean
  type: HOUSE_TYPES
  residency: House_RESIDENCY
  lease: Int!
  rooms: RoomCreateManyWithoutHouseInput
  views: ViewsCreateOneWithoutHouseInput
  bookings: BookingCreateManyWithoutHouseInput
  contactInfoPayments: PaymentLanlordInfoCreateManyWithoutHouseInput
  popularity: Int
  preview_image: PictureCreateOneInput
}

input HouseCreateManyWithoutHostInput {
  create: [HouseCreateWithoutHostInput!]
  connect: [HouseWhereUniqueInput!]
}

input HouseCreateOneInput {
  create: HouseCreateInput
  connect: HouseWhereUniqueInput
}

input HouseCreateOneWithoutAmenitiesInput {
  create: HouseCreateWithoutAmenitiesInput
  connect: HouseWhereUniqueInput
}

input HouseCreateOneWithoutBookingsInput {
  create: HouseCreateWithoutBookingsInput
  connect: HouseWhereUniqueInput
}

input HouseCreateOneWithoutContactInfoPaymentsInput {
  create: HouseCreateWithoutContactInfoPaymentsInput
  connect: HouseWhereUniqueInput
}

input HouseCreateOneWithoutPricingInput {
  create: HouseCreateWithoutPricingInput
  connect: HouseWhereUniqueInput
}

input HouseCreateOneWithoutReviewsInput {
  create: HouseCreateWithoutReviewsInput
  connect: HouseWhereUniqueInput
}

input HouseCreateOneWithoutRoomsInput {
  create: HouseCreateWithoutRoomsInput
  connect: HouseWhereUniqueInput
}

input HouseCreateOneWithoutViewsInput {
  create: HouseCreateWithoutViewsInput
  connect: HouseWhereUniqueInput
}

input HouseCreateWithoutAmenitiesInput {
  id: ID
  area: Int
  age: Int
  shortDescription: String
  description: String
  maxGuests: Int!
  numBedrooms: Int!
  numBaths: Int!
  numLivingrooms: Int
  numDiningrooms: Int
  reviews: ReviewCreateManyWithoutHouseInput
  host: UserCreateOneWithoutOwnedHousesInput!
  pricing: PricingCreateOneWithoutHouseInput!
  location: LocationCreateOneInput!
  leaseType: HOUSE_LEASE_TYPE
  verified: Boolean
  type: HOUSE_TYPES
  residency: House_RESIDENCY
  lease: Int!
  rooms: RoomCreateManyWithoutHouseInput
  views: ViewsCreateOneWithoutHouseInput
  bookings: BookingCreateManyWithoutHouseInput
  contactInfoPayments: PaymentLanlordInfoCreateManyWithoutHouseInput
  popularity: Int
  preview_image: PictureCreateOneInput
}

input HouseCreateWithoutBookingsInput {
  id: ID
  area: Int
  age: Int
  shortDescription: String
  description: String
  maxGuests: Int!
  numBedrooms: Int!
  numBaths: Int!
  numLivingrooms: Int
  numDiningrooms: Int
  reviews: ReviewCreateManyWithoutHouseInput
  amenities: AmenitiesCreateOneWithoutHouseInput!
  host: UserCreateOneWithoutOwnedHousesInput!
  pricing: PricingCreateOneWithoutHouseInput!
  location: LocationCreateOneInput!
  leaseType: HOUSE_LEASE_TYPE
  verified: Boolean
  type: HOUSE_TYPES
  residency: House_RESIDENCY
  lease: Int!
  rooms: RoomCreateManyWithoutHouseInput
  views: ViewsCreateOneWithoutHouseInput
  contactInfoPayments: PaymentLanlordInfoCreateManyWithoutHouseInput
  popularity: Int
  preview_image: PictureCreateOneInput
}

input HouseCreateWithoutContactInfoPaymentsInput {
  id: ID
  area: Int
  age: Int
  shortDescription: String
  description: String
  maxGuests: Int!
  numBedrooms: Int!
  numBaths: Int!
  numLivingrooms: Int
  numDiningrooms: Int
  reviews: ReviewCreateManyWithoutHouseInput
  amenities: AmenitiesCreateOneWithoutHouseInput!
  host: UserCreateOneWithoutOwnedHousesInput!
  pricing: PricingCreateOneWithoutHouseInput!
  location: LocationCreateOneInput!
  leaseType: HOUSE_LEASE_TYPE
  verified: Boolean
  type: HOUSE_TYPES
  residency: House_RESIDENCY
  lease: Int!
  rooms: RoomCreateManyWithoutHouseInput
  views: ViewsCreateOneWithoutHouseInput
  bookings: BookingCreateManyWithoutHouseInput
  popularity: Int
  preview_image: PictureCreateOneInput
}

input HouseCreateWithoutHostInput {
  id: ID
  area: Int
  age: Int
  shortDescription: String
  description: String
  maxGuests: Int!
  numBedrooms: Int!
  numBaths: Int!
  numLivingrooms: Int
  numDiningrooms: Int
  reviews: ReviewCreateManyWithoutHouseInput
  amenities: AmenitiesCreateOneWithoutHouseInput!
  pricing: PricingCreateOneWithoutHouseInput!
  location: LocationCreateOneInput!
  leaseType: HOUSE_LEASE_TYPE
  verified: Boolean
  type: HOUSE_TYPES
  residency: House_RESIDENCY
  lease: Int!
  rooms: RoomCreateManyWithoutHouseInput
  views: ViewsCreateOneWithoutHouseInput
  bookings: BookingCreateManyWithoutHouseInput
  contactInfoPayments: PaymentLanlordInfoCreateManyWithoutHouseInput
  popularity: Int
  preview_image: PictureCreateOneInput
}

input HouseCreateWithoutPricingInput {
  id: ID
  area: Int
  age: Int
  shortDescription: String
  description: String
  maxGuests: Int!
  numBedrooms: Int!
  numBaths: Int!
  numLivingrooms: Int
  numDiningrooms: Int
  reviews: ReviewCreateManyWithoutHouseInput
  amenities: AmenitiesCreateOneWithoutHouseInput!
  host: UserCreateOneWithoutOwnedHousesInput!
  location: LocationCreateOneInput!
  leaseType: HOUSE_LEASE_TYPE
  verified: Boolean
  type: HOUSE_TYPES
  residency: House_RESIDENCY
  lease: Int!
  rooms: RoomCreateManyWithoutHouseInput
  views: ViewsCreateOneWithoutHouseInput
  bookings: BookingCreateManyWithoutHouseInput
  contactInfoPayments: PaymentLanlordInfoCreateManyWithoutHouseInput
  popularity: Int
  preview_image: PictureCreateOneInput
}

input HouseCreateWithoutReviewsInput {
  id: ID
  area: Int
  age: Int
  shortDescription: String
  description: String
  maxGuests: Int!
  numBedrooms: Int!
  numBaths: Int!
  numLivingrooms: Int
  numDiningrooms: Int
  amenities: AmenitiesCreateOneWithoutHouseInput!
  host: UserCreateOneWithoutOwnedHousesInput!
  pricing: PricingCreateOneWithoutHouseInput!
  location: LocationCreateOneInput!
  leaseType: HOUSE_LEASE_TYPE
  verified: Boolean
  type: HOUSE_TYPES
  residency: House_RESIDENCY
  lease: Int!
  rooms: RoomCreateManyWithoutHouseInput
  views: ViewsCreateOneWithoutHouseInput
  bookings: BookingCreateManyWithoutHouseInput
  contactInfoPayments: PaymentLanlordInfoCreateManyWithoutHouseInput
  popularity: Int
  preview_image: PictureCreateOneInput
}

input HouseCreateWithoutRoomsInput {
  id: ID
  area: Int
  age: Int
  shortDescription: String
  description: String
  maxGuests: Int!
  numBedrooms: Int!
  numBaths: Int!
  numLivingrooms: Int
  numDiningrooms: Int
  reviews: ReviewCreateManyWithoutHouseInput
  amenities: AmenitiesCreateOneWithoutHouseInput!
  host: UserCreateOneWithoutOwnedHousesInput!
  pricing: PricingCreateOneWithoutHouseInput!
  location: LocationCreateOneInput!
  leaseType: HOUSE_LEASE_TYPE
  verified: Boolean
  type: HOUSE_TYPES
  residency: House_RESIDENCY
  lease: Int!
  views: ViewsCreateOneWithoutHouseInput
  bookings: BookingCreateManyWithoutHouseInput
  contactInfoPayments: PaymentLanlordInfoCreateManyWithoutHouseInput
  popularity: Int
  preview_image: PictureCreateOneInput
}

input HouseCreateWithoutViewsInput {
  id: ID
  area: Int
  age: Int
  shortDescription: String
  description: String
  maxGuests: Int!
  numBedrooms: Int!
  numBaths: Int!
  numLivingrooms: Int
  numDiningrooms: Int
  reviews: ReviewCreateManyWithoutHouseInput
  amenities: AmenitiesCreateOneWithoutHouseInput!
  host: UserCreateOneWithoutOwnedHousesInput!
  pricing: PricingCreateOneWithoutHouseInput!
  location: LocationCreateOneInput!
  leaseType: HOUSE_LEASE_TYPE
  verified: Boolean
  type: HOUSE_TYPES
  residency: House_RESIDENCY
  lease: Int!
  rooms: RoomCreateManyWithoutHouseInput
  bookings: BookingCreateManyWithoutHouseInput
  contactInfoPayments: PaymentLanlordInfoCreateManyWithoutHouseInput
  popularity: Int
  preview_image: PictureCreateOneInput
}

type HouseEdge {
  node: House!
  cursor: String!
}

enum HouseOrderByInput {
  id_ASC
  id_DESC
  area_ASC
  area_DESC
  age_ASC
  age_DESC
  shortDescription_ASC
  shortDescription_DESC
  description_ASC
  description_DESC
  maxGuests_ASC
  maxGuests_DESC
  numBedrooms_ASC
  numBedrooms_DESC
  numBaths_ASC
  numBaths_DESC
  numLivingrooms_ASC
  numLivingrooms_DESC
  numDiningrooms_ASC
  numDiningrooms_DESC
  leaseType_ASC
  leaseType_DESC
  verified_ASC
  verified_DESC
  type_ASC
  type_DESC
  residency_ASC
  residency_DESC
  lease_ASC
  lease_DESC
  popularity_ASC
  popularity_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type HousePreviousValues {
  id: ID!
  area: Int
  age: Int
  shortDescription: String
  description: String
  maxGuests: Int!
  numBedrooms: Int!
  numBaths: Int!
  numLivingrooms: Int
  numDiningrooms: Int
  leaseType: HOUSE_LEASE_TYPE
  verified: Boolean!
  type: HOUSE_TYPES
  residency: House_RESIDENCY
  lease: Int!
  popularity: Int!
  createdAt: DateTime!
  updatedAt: DateTime!
}

input HouseScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  area: Int
  area_not: Int
  area_in: [Int!]
  area_not_in: [Int!]
  area_lt: Int
  area_lte: Int
  area_gt: Int
  area_gte: Int
  age: Int
  age_not: Int
  age_in: [Int!]
  age_not_in: [Int!]
  age_lt: Int
  age_lte: Int
  age_gt: Int
  age_gte: Int
  shortDescription: String
  shortDescription_not: String
  shortDescription_in: [String!]
  shortDescription_not_in: [String!]
  shortDescription_lt: String
  shortDescription_lte: String
  shortDescription_gt: String
  shortDescription_gte: String
  shortDescription_contains: String
  shortDescription_not_contains: String
  shortDescription_starts_with: String
  shortDescription_not_starts_with: String
  shortDescription_ends_with: String
  shortDescription_not_ends_with: String
  description: String
  description_not: String
  description_in: [String!]
  description_not_in: [String!]
  description_lt: String
  description_lte: String
  description_gt: String
  description_gte: String
  description_contains: String
  description_not_contains: String
  description_starts_with: String
  description_not_starts_with: String
  description_ends_with: String
  description_not_ends_with: String
  maxGuests: Int
  maxGuests_not: Int
  maxGuests_in: [Int!]
  maxGuests_not_in: [Int!]
  maxGuests_lt: Int
  maxGuests_lte: Int
  maxGuests_gt: Int
  maxGuests_gte: Int
  numBedrooms: Int
  numBedrooms_not: Int
  numBedrooms_in: [Int!]
  numBedrooms_not_in: [Int!]
  numBedrooms_lt: Int
  numBedrooms_lte: Int
  numBedrooms_gt: Int
  numBedrooms_gte: Int
  numBaths: Int
  numBaths_not: Int
  numBaths_in: [Int!]
  numBaths_not_in: [Int!]
  numBaths_lt: Int
  numBaths_lte: Int
  numBaths_gt: Int
  numBaths_gte: Int
  numLivingrooms: Int
  numLivingrooms_not: Int
  numLivingrooms_in: [Int!]
  numLivingrooms_not_in: [Int!]
  numLivingrooms_lt: Int
  numLivingrooms_lte: Int
  numLivingrooms_gt: Int
  numLivingrooms_gte: Int
  numDiningrooms: Int
  numDiningrooms_not: Int
  numDiningrooms_in: [Int!]
  numDiningrooms_not_in: [Int!]
  numDiningrooms_lt: Int
  numDiningrooms_lte: Int
  numDiningrooms_gt: Int
  numDiningrooms_gte: Int
  leaseType: HOUSE_LEASE_TYPE
  leaseType_not: HOUSE_LEASE_TYPE
  leaseType_in: [HOUSE_LEASE_TYPE!]
  leaseType_not_in: [HOUSE_LEASE_TYPE!]
  verified: Boolean
  verified_not: Boolean
  type: HOUSE_TYPES
  type_not: HOUSE_TYPES
  type_in: [HOUSE_TYPES!]
  type_not_in: [HOUSE_TYPES!]
  residency: House_RESIDENCY
  residency_not: House_RESIDENCY
  residency_in: [House_RESIDENCY!]
  residency_not_in: [House_RESIDENCY!]
  lease: Int
  lease_not: Int
  lease_in: [Int!]
  lease_not_in: [Int!]
  lease_lt: Int
  lease_lte: Int
  lease_gt: Int
  lease_gte: Int
  popularity: Int
  popularity_not: Int
  popularity_in: [Int!]
  popularity_not_in: [Int!]
  popularity_lt: Int
  popularity_lte: Int
  popularity_gt: Int
  popularity_gte: Int
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [HouseScalarWhereInput!]
  OR: [HouseScalarWhereInput!]
  NOT: [HouseScalarWhereInput!]
}

type HouseSubscriptionPayload {
  mutation: MutationType!
  node: House
  updatedFields: [String!]
  previousValues: HousePreviousValues
}

input HouseSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: HouseWhereInput
  AND: [HouseSubscriptionWhereInput!]
  OR: [HouseSubscriptionWhereInput!]
  NOT: [HouseSubscriptionWhereInput!]
}

input HouseUpdateDataInput {
  area: Int
  age: Int
  shortDescription: String
  description: String
  maxGuests: Int
  numBedrooms: Int
  numBaths: Int
  numLivingrooms: Int
  numDiningrooms: Int
  reviews: ReviewUpdateManyWithoutHouseInput
  amenities: AmenitiesUpdateOneRequiredWithoutHouseInput
  host: UserUpdateOneRequiredWithoutOwnedHousesInput
  pricing: PricingUpdateOneRequiredWithoutHouseInput
  location: LocationUpdateOneRequiredInput
  leaseType: HOUSE_LEASE_TYPE
  verified: Boolean
  type: HOUSE_TYPES
  residency: House_RESIDENCY
  lease: Int
  rooms: RoomUpdateManyWithoutHouseInput
  views: ViewsUpdateOneWithoutHouseInput
  bookings: BookingUpdateManyWithoutHouseInput
  contactInfoPayments: PaymentLanlordInfoUpdateManyWithoutHouseInput
  popularity: Int
  preview_image: PictureUpdateOneInput
}

input HouseUpdateInput {
  area: Int
  age: Int
  shortDescription: String
  description: String
  maxGuests: Int
  numBedrooms: Int
  numBaths: Int
  numLivingrooms: Int
  numDiningrooms: Int
  reviews: ReviewUpdateManyWithoutHouseInput
  amenities: AmenitiesUpdateOneRequiredWithoutHouseInput
  host: UserUpdateOneRequiredWithoutOwnedHousesInput
  pricing: PricingUpdateOneRequiredWithoutHouseInput
  location: LocationUpdateOneRequiredInput
  leaseType: HOUSE_LEASE_TYPE
  verified: Boolean
  type: HOUSE_TYPES
  residency: House_RESIDENCY
  lease: Int
  rooms: RoomUpdateManyWithoutHouseInput
  views: ViewsUpdateOneWithoutHouseInput
  bookings: BookingUpdateManyWithoutHouseInput
  contactInfoPayments: PaymentLanlordInfoUpdateManyWithoutHouseInput
  popularity: Int
  preview_image: PictureUpdateOneInput
}

input HouseUpdateManyDataInput {
  area: Int
  age: Int
  shortDescription: String
  description: String
  maxGuests: Int
  numBedrooms: Int
  numBaths: Int
  numLivingrooms: Int
  numDiningrooms: Int
  leaseType: HOUSE_LEASE_TYPE
  verified: Boolean
  type: HOUSE_TYPES
  residency: House_RESIDENCY
  lease: Int
  popularity: Int
}

input HouseUpdateManyMutationInput {
  area: Int
  age: Int
  shortDescription: String
  description: String
  maxGuests: Int
  numBedrooms: Int
  numBaths: Int
  numLivingrooms: Int
  numDiningrooms: Int
  leaseType: HOUSE_LEASE_TYPE
  verified: Boolean
  type: HOUSE_TYPES
  residency: House_RESIDENCY
  lease: Int
  popularity: Int
}

input HouseUpdateManyWithoutHostInput {
  create: [HouseCreateWithoutHostInput!]
  delete: [HouseWhereUniqueInput!]
  connect: [HouseWhereUniqueInput!]
  set: [HouseWhereUniqueInput!]
  disconnect: [HouseWhereUniqueInput!]
  update: [HouseUpdateWithWhereUniqueWithoutHostInput!]
  upsert: [HouseUpsertWithWhereUniqueWithoutHostInput!]
  deleteMany: [HouseScalarWhereInput!]
  updateMany: [HouseUpdateManyWithWhereNestedInput!]
}

input HouseUpdateManyWithWhereNestedInput {
  where: HouseScalarWhereInput!
  data: HouseUpdateManyDataInput!
}

input HouseUpdateOneRequiredInput {
  create: HouseCreateInput
  update: HouseUpdateDataInput
  upsert: HouseUpsertNestedInput
  connect: HouseWhereUniqueInput
}

input HouseUpdateOneRequiredWithoutAmenitiesInput {
  create: HouseCreateWithoutAmenitiesInput
  update: HouseUpdateWithoutAmenitiesDataInput
  upsert: HouseUpsertWithoutAmenitiesInput
  connect: HouseWhereUniqueInput
}

input HouseUpdateOneRequiredWithoutBookingsInput {
  create: HouseCreateWithoutBookingsInput
  update: HouseUpdateWithoutBookingsDataInput
  upsert: HouseUpsertWithoutBookingsInput
  connect: HouseWhereUniqueInput
}

input HouseUpdateOneRequiredWithoutContactInfoPaymentsInput {
  create: HouseCreateWithoutContactInfoPaymentsInput
  update: HouseUpdateWithoutContactInfoPaymentsDataInput
  upsert: HouseUpsertWithoutContactInfoPaymentsInput
  connect: HouseWhereUniqueInput
}

input HouseUpdateOneRequiredWithoutPricingInput {
  create: HouseCreateWithoutPricingInput
  update: HouseUpdateWithoutPricingDataInput
  upsert: HouseUpsertWithoutPricingInput
  connect: HouseWhereUniqueInput
}

input HouseUpdateOneRequiredWithoutReviewsInput {
  create: HouseCreateWithoutReviewsInput
  update: HouseUpdateWithoutReviewsDataInput
  upsert: HouseUpsertWithoutReviewsInput
  connect: HouseWhereUniqueInput
}

input HouseUpdateOneRequiredWithoutRoomsInput {
  create: HouseCreateWithoutRoomsInput
  update: HouseUpdateWithoutRoomsDataInput
  upsert: HouseUpsertWithoutRoomsInput
  connect: HouseWhereUniqueInput
}

input HouseUpdateOneRequiredWithoutViewsInput {
  create: HouseCreateWithoutViewsInput
  update: HouseUpdateWithoutViewsDataInput
  upsert: HouseUpsertWithoutViewsInput
  connect: HouseWhereUniqueInput
}

input HouseUpdateWithoutAmenitiesDataInput {
  area: Int
  age: Int
  shortDescription: String
  description: String
  maxGuests: Int
  numBedrooms: Int
  numBaths: Int
  numLivingrooms: Int
  numDiningrooms: Int
  reviews: ReviewUpdateManyWithoutHouseInput
  host: UserUpdateOneRequiredWithoutOwnedHousesInput
  pricing: PricingUpdateOneRequiredWithoutHouseInput
  location: LocationUpdateOneRequiredInput
  leaseType: HOUSE_LEASE_TYPE
  verified: Boolean
  type: HOUSE_TYPES
  residency: House_RESIDENCY
  lease: Int
  rooms: RoomUpdateManyWithoutHouseInput
  views: ViewsUpdateOneWithoutHouseInput
  bookings: BookingUpdateManyWithoutHouseInput
  contactInfoPayments: PaymentLanlordInfoUpdateManyWithoutHouseInput
  popularity: Int
  preview_image: PictureUpdateOneInput
}

input HouseUpdateWithoutBookingsDataInput {
  area: Int
  age: Int
  shortDescription: String
  description: String
  maxGuests: Int
  numBedrooms: Int
  numBaths: Int
  numLivingrooms: Int
  numDiningrooms: Int
  reviews: ReviewUpdateManyWithoutHouseInput
  amenities: AmenitiesUpdateOneRequiredWithoutHouseInput
  host: UserUpdateOneRequiredWithoutOwnedHousesInput
  pricing: PricingUpdateOneRequiredWithoutHouseInput
  location: LocationUpdateOneRequiredInput
  leaseType: HOUSE_LEASE_TYPE
  verified: Boolean
  type: HOUSE_TYPES
  residency: House_RESIDENCY
  lease: Int
  rooms: RoomUpdateManyWithoutHouseInput
  views: ViewsUpdateOneWithoutHouseInput
  contactInfoPayments: PaymentLanlordInfoUpdateManyWithoutHouseInput
  popularity: Int
  preview_image: PictureUpdateOneInput
}

input HouseUpdateWithoutContactInfoPaymentsDataInput {
  area: Int
  age: Int
  shortDescription: String
  description: String
  maxGuests: Int
  numBedrooms: Int
  numBaths: Int
  numLivingrooms: Int
  numDiningrooms: Int
  reviews: ReviewUpdateManyWithoutHouseInput
  amenities: AmenitiesUpdateOneRequiredWithoutHouseInput
  host: UserUpdateOneRequiredWithoutOwnedHousesInput
  pricing: PricingUpdateOneRequiredWithoutHouseInput
  location: LocationUpdateOneRequiredInput
  leaseType: HOUSE_LEASE_TYPE
  verified: Boolean
  type: HOUSE_TYPES
  residency: House_RESIDENCY
  lease: Int
  rooms: RoomUpdateManyWithoutHouseInput
  views: ViewsUpdateOneWithoutHouseInput
  bookings: BookingUpdateManyWithoutHouseInput
  popularity: Int
  preview_image: PictureUpdateOneInput
}

input HouseUpdateWithoutHostDataInput {
  area: Int
  age: Int
  shortDescription: String
  description: String
  maxGuests: Int
  numBedrooms: Int
  numBaths: Int
  numLivingrooms: Int
  numDiningrooms: Int
  reviews: ReviewUpdateManyWithoutHouseInput
  amenities: AmenitiesUpdateOneRequiredWithoutHouseInput
  pricing: PricingUpdateOneRequiredWithoutHouseInput
  location: LocationUpdateOneRequiredInput
  leaseType: HOUSE_LEASE_TYPE
  verified: Boolean
  type: HOUSE_TYPES
  residency: House_RESIDENCY
  lease: Int
  rooms: RoomUpdateManyWithoutHouseInput
  views: ViewsUpdateOneWithoutHouseInput
  bookings: BookingUpdateManyWithoutHouseInput
  contactInfoPayments: PaymentLanlordInfoUpdateManyWithoutHouseInput
  popularity: Int
  preview_image: PictureUpdateOneInput
}

input HouseUpdateWithoutPricingDataInput {
  area: Int
  age: Int
  shortDescription: String
  description: String
  maxGuests: Int
  numBedrooms: Int
  numBaths: Int
  numLivingrooms: Int
  numDiningrooms: Int
  reviews: ReviewUpdateManyWithoutHouseInput
  amenities: AmenitiesUpdateOneRequiredWithoutHouseInput
  host: UserUpdateOneRequiredWithoutOwnedHousesInput
  location: LocationUpdateOneRequiredInput
  leaseType: HOUSE_LEASE_TYPE
  verified: Boolean
  type: HOUSE_TYPES
  residency: House_RESIDENCY
  lease: Int
  rooms: RoomUpdateManyWithoutHouseInput
  views: ViewsUpdateOneWithoutHouseInput
  bookings: BookingUpdateManyWithoutHouseInput
  contactInfoPayments: PaymentLanlordInfoUpdateManyWithoutHouseInput
  popularity: Int
  preview_image: PictureUpdateOneInput
}

input HouseUpdateWithoutReviewsDataInput {
  area: Int
  age: Int
  shortDescription: String
  description: String
  maxGuests: Int
  numBedrooms: Int
  numBaths: Int
  numLivingrooms: Int
  numDiningrooms: Int
  amenities: AmenitiesUpdateOneRequiredWithoutHouseInput
  host: UserUpdateOneRequiredWithoutOwnedHousesInput
  pricing: PricingUpdateOneRequiredWithoutHouseInput
  location: LocationUpdateOneRequiredInput
  leaseType: HOUSE_LEASE_TYPE
  verified: Boolean
  type: HOUSE_TYPES
  residency: House_RESIDENCY
  lease: Int
  rooms: RoomUpdateManyWithoutHouseInput
  views: ViewsUpdateOneWithoutHouseInput
  bookings: BookingUpdateManyWithoutHouseInput
  contactInfoPayments: PaymentLanlordInfoUpdateManyWithoutHouseInput
  popularity: Int
  preview_image: PictureUpdateOneInput
}

input HouseUpdateWithoutRoomsDataInput {
  area: Int
  age: Int
  shortDescription: String
  description: String
  maxGuests: Int
  numBedrooms: Int
  numBaths: Int
  numLivingrooms: Int
  numDiningrooms: Int
  reviews: ReviewUpdateManyWithoutHouseInput
  amenities: AmenitiesUpdateOneRequiredWithoutHouseInput
  host: UserUpdateOneRequiredWithoutOwnedHousesInput
  pricing: PricingUpdateOneRequiredWithoutHouseInput
  location: LocationUpdateOneRequiredInput
  leaseType: HOUSE_LEASE_TYPE
  verified: Boolean
  type: HOUSE_TYPES
  residency: House_RESIDENCY
  lease: Int
  views: ViewsUpdateOneWithoutHouseInput
  bookings: BookingUpdateManyWithoutHouseInput
  contactInfoPayments: PaymentLanlordInfoUpdateManyWithoutHouseInput
  popularity: Int
  preview_image: PictureUpdateOneInput
}

input HouseUpdateWithoutViewsDataInput {
  area: Int
  age: Int
  shortDescription: String
  description: String
  maxGuests: Int
  numBedrooms: Int
  numBaths: Int
  numLivingrooms: Int
  numDiningrooms: Int
  reviews: ReviewUpdateManyWithoutHouseInput
  amenities: AmenitiesUpdateOneRequiredWithoutHouseInput
  host: UserUpdateOneRequiredWithoutOwnedHousesInput
  pricing: PricingUpdateOneRequiredWithoutHouseInput
  location: LocationUpdateOneRequiredInput
  leaseType: HOUSE_LEASE_TYPE
  verified: Boolean
  type: HOUSE_TYPES
  residency: House_RESIDENCY
  lease: Int
  rooms: RoomUpdateManyWithoutHouseInput
  bookings: BookingUpdateManyWithoutHouseInput
  contactInfoPayments: PaymentLanlordInfoUpdateManyWithoutHouseInput
  popularity: Int
  preview_image: PictureUpdateOneInput
}

input HouseUpdateWithWhereUniqueWithoutHostInput {
  where: HouseWhereUniqueInput!
  data: HouseUpdateWithoutHostDataInput!
}

input HouseUpsertNestedInput {
  update: HouseUpdateDataInput!
  create: HouseCreateInput!
}

input HouseUpsertWithoutAmenitiesInput {
  update: HouseUpdateWithoutAmenitiesDataInput!
  create: HouseCreateWithoutAmenitiesInput!
}

input HouseUpsertWithoutBookingsInput {
  update: HouseUpdateWithoutBookingsDataInput!
  create: HouseCreateWithoutBookingsInput!
}

input HouseUpsertWithoutContactInfoPaymentsInput {
  update: HouseUpdateWithoutContactInfoPaymentsDataInput!
  create: HouseCreateWithoutContactInfoPaymentsInput!
}

input HouseUpsertWithoutPricingInput {
  update: HouseUpdateWithoutPricingDataInput!
  create: HouseCreateWithoutPricingInput!
}

input HouseUpsertWithoutReviewsInput {
  update: HouseUpdateWithoutReviewsDataInput!
  create: HouseCreateWithoutReviewsInput!
}

input HouseUpsertWithoutRoomsInput {
  update: HouseUpdateWithoutRoomsDataInput!
  create: HouseCreateWithoutRoomsInput!
}

input HouseUpsertWithoutViewsInput {
  update: HouseUpdateWithoutViewsDataInput!
  create: HouseCreateWithoutViewsInput!
}

input HouseUpsertWithWhereUniqueWithoutHostInput {
  where: HouseWhereUniqueInput!
  update: HouseUpdateWithoutHostDataInput!
  create: HouseCreateWithoutHostInput!
}

input HouseWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  area: Int
  area_not: Int
  area_in: [Int!]
  area_not_in: [Int!]
  area_lt: Int
  area_lte: Int
  area_gt: Int
  area_gte: Int
  age: Int
  age_not: Int
  age_in: [Int!]
  age_not_in: [Int!]
  age_lt: Int
  age_lte: Int
  age_gt: Int
  age_gte: Int
  shortDescription: String
  shortDescription_not: String
  shortDescription_in: [String!]
  shortDescription_not_in: [String!]
  shortDescription_lt: String
  shortDescription_lte: String
  shortDescription_gt: String
  shortDescription_gte: String
  shortDescription_contains: String
  shortDescription_not_contains: String
  shortDescription_starts_with: String
  shortDescription_not_starts_with: String
  shortDescription_ends_with: String
  shortDescription_not_ends_with: String
  description: String
  description_not: String
  description_in: [String!]
  description_not_in: [String!]
  description_lt: String
  description_lte: String
  description_gt: String
  description_gte: String
  description_contains: String
  description_not_contains: String
  description_starts_with: String
  description_not_starts_with: String
  description_ends_with: String
  description_not_ends_with: String
  maxGuests: Int
  maxGuests_not: Int
  maxGuests_in: [Int!]
  maxGuests_not_in: [Int!]
  maxGuests_lt: Int
  maxGuests_lte: Int
  maxGuests_gt: Int
  maxGuests_gte: Int
  numBedrooms: Int
  numBedrooms_not: Int
  numBedrooms_in: [Int!]
  numBedrooms_not_in: [Int!]
  numBedrooms_lt: Int
  numBedrooms_lte: Int
  numBedrooms_gt: Int
  numBedrooms_gte: Int
  numBaths: Int
  numBaths_not: Int
  numBaths_in: [Int!]
  numBaths_not_in: [Int!]
  numBaths_lt: Int
  numBaths_lte: Int
  numBaths_gt: Int
  numBaths_gte: Int
  numLivingrooms: Int
  numLivingrooms_not: Int
  numLivingrooms_in: [Int!]
  numLivingrooms_not_in: [Int!]
  numLivingrooms_lt: Int
  numLivingrooms_lte: Int
  numLivingrooms_gt: Int
  numLivingrooms_gte: Int
  numDiningrooms: Int
  numDiningrooms_not: Int
  numDiningrooms_in: [Int!]
  numDiningrooms_not_in: [Int!]
  numDiningrooms_lt: Int
  numDiningrooms_lte: Int
  numDiningrooms_gt: Int
  numDiningrooms_gte: Int
  reviews_every: ReviewWhereInput
  reviews_some: ReviewWhereInput
  reviews_none: ReviewWhereInput
  amenities: AmenitiesWhereInput
  host: UserWhereInput
  pricing: PricingWhereInput
  location: LocationWhereInput
  leaseType: HOUSE_LEASE_TYPE
  leaseType_not: HOUSE_LEASE_TYPE
  leaseType_in: [HOUSE_LEASE_TYPE!]
  leaseType_not_in: [HOUSE_LEASE_TYPE!]
  verified: Boolean
  verified_not: Boolean
  type: HOUSE_TYPES
  type_not: HOUSE_TYPES
  type_in: [HOUSE_TYPES!]
  type_not_in: [HOUSE_TYPES!]
  residency: House_RESIDENCY
  residency_not: House_RESIDENCY
  residency_in: [House_RESIDENCY!]
  residency_not_in: [House_RESIDENCY!]
  lease: Int
  lease_not: Int
  lease_in: [Int!]
  lease_not_in: [Int!]
  lease_lt: Int
  lease_lte: Int
  lease_gt: Int
  lease_gte: Int
  rooms_every: RoomWhereInput
  rooms_some: RoomWhereInput
  rooms_none: RoomWhereInput
  views: ViewsWhereInput
  bookings_every: BookingWhereInput
  bookings_some: BookingWhereInput
  bookings_none: BookingWhereInput
  contactInfoPayments_every: PaymentLanlordInfoWhereInput
  contactInfoPayments_some: PaymentLanlordInfoWhereInput
  contactInfoPayments_none: PaymentLanlordInfoWhereInput
  popularity: Int
  popularity_not: Int
  popularity_in: [Int!]
  popularity_not_in: [Int!]
  popularity_lt: Int
  popularity_lte: Int
  popularity_gt: Int
  popularity_gte: Int
  preview_image: PictureWhereInput
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [HouseWhereInput!]
  OR: [HouseWhereInput!]
  NOT: [HouseWhereInput!]
}

input HouseWhereUniqueInput {
  id: ID
}

type Location {
  id: ID!
  lat: Float
  lng: Float
  address: String
  commune: Commune
  createdAt: DateTime!
  updatedAt: DateTime!
}

type LocationConnection {
  pageInfo: PageInfo!
  edges: [LocationEdge]!
  aggregate: AggregateLocation!
}

input LocationCreateInput {
  id: ID
  lat: Float
  lng: Float
  address: String
  commune: CommuneCreateOneInput
}

input LocationCreateOneInput {
  create: LocationCreateInput
  connect: LocationWhereUniqueInput
}

type LocationEdge {
  node: Location!
  cursor: String!
}

enum LocationOrderByInput {
  id_ASC
  id_DESC
  lat_ASC
  lat_DESC
  lng_ASC
  lng_DESC
  address_ASC
  address_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type LocationPreviousValues {
  id: ID!
  lat: Float
  lng: Float
  address: String
  createdAt: DateTime!
  updatedAt: DateTime!
}

type LocationSubscriptionPayload {
  mutation: MutationType!
  node: Location
  updatedFields: [String!]
  previousValues: LocationPreviousValues
}

input LocationSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: LocationWhereInput
  AND: [LocationSubscriptionWhereInput!]
  OR: [LocationSubscriptionWhereInput!]
  NOT: [LocationSubscriptionWhereInput!]
}

input LocationUpdateDataInput {
  lat: Float
  lng: Float
  address: String
  commune: CommuneUpdateOneInput
}

input LocationUpdateInput {
  lat: Float
  lng: Float
  address: String
  commune: CommuneUpdateOneInput
}

input LocationUpdateManyMutationInput {
  lat: Float
  lng: Float
  address: String
}

input LocationUpdateOneInput {
  create: LocationCreateInput
  update: LocationUpdateDataInput
  upsert: LocationUpsertNestedInput
  delete: Boolean
  disconnect: Boolean
  connect: LocationWhereUniqueInput
}

input LocationUpdateOneRequiredInput {
  create: LocationCreateInput
  update: LocationUpdateDataInput
  upsert: LocationUpsertNestedInput
  connect: LocationWhereUniqueInput
}

input LocationUpsertNestedInput {
  update: LocationUpdateDataInput!
  create: LocationCreateInput!
}

input LocationWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  lat: Float
  lat_not: Float
  lat_in: [Float!]
  lat_not_in: [Float!]
  lat_lt: Float
  lat_lte: Float
  lat_gt: Float
  lat_gte: Float
  lng: Float
  lng_not: Float
  lng_in: [Float!]
  lng_not_in: [Float!]
  lng_lt: Float
  lng_lte: Float
  lng_gt: Float
  lng_gte: Float
  address: String
  address_not: String
  address_in: [String!]
  address_not_in: [String!]
  address_lt: String
  address_lte: String
  address_gt: String
  address_gte: String
  address_contains: String
  address_not_contains: String
  address_starts_with: String
  address_not_starts_with: String
  address_ends_with: String
  address_not_ends_with: String
  commune: CommuneWhereInput
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [LocationWhereInput!]
  OR: [LocationWhereInput!]
  NOT: [LocationWhereInput!]
}

input LocationWhereUniqueInput {
  id: ID
}

scalar Long

type Mutation {
  createAmenities(data: AmenitiesCreateInput!): Amenities!
  updateAmenities(data: AmenitiesUpdateInput!, where: AmenitiesWhereUniqueInput!): Amenities
  updateManyAmenitieses(data: AmenitiesUpdateManyMutationInput!, where: AmenitiesWhereInput): BatchPayload!
  upsertAmenities(where: AmenitiesWhereUniqueInput!, create: AmenitiesCreateInput!, update: AmenitiesUpdateInput!): Amenities!
  deleteAmenities(where: AmenitiesWhereUniqueInput!): Amenities
  deleteManyAmenitieses(where: AmenitiesWhereInput): BatchPayload!
  createBooking(data: BookingCreateInput!): Booking!
  updateBooking(data: BookingUpdateInput!, where: BookingWhereUniqueInput!): Booking
  updateManyBookings(data: BookingUpdateManyMutationInput!, where: BookingWhereInput): BatchPayload!
  upsertBooking(where: BookingWhereUniqueInput!, create: BookingCreateInput!, update: BookingUpdateInput!): Booking!
  deleteBooking(where: BookingWhereUniqueInput!): Booking
  deleteManyBookings(where: BookingWhereInput): BatchPayload!
  createCity(data: CityCreateInput!): City!
  updateCity(data: CityUpdateInput!, where: CityWhereUniqueInput!): City
  updateManyCities(data: CityUpdateManyMutationInput!, where: CityWhereInput): BatchPayload!
  upsertCity(where: CityWhereUniqueInput!, create: CityCreateInput!, update: CityUpdateInput!): City!
  deleteCity(where: CityWhereUniqueInput!): City
  deleteManyCities(where: CityWhereInput): BatchPayload!
  createCommune(data: CommuneCreateInput!): Commune!
  updateCommune(data: CommuneUpdateInput!, where: CommuneWhereUniqueInput!): Commune
  updateManyCommunes(data: CommuneUpdateManyMutationInput!, where: CommuneWhereInput): BatchPayload!
  upsertCommune(where: CommuneWhereUniqueInput!, create: CommuneCreateInput!, update: CommuneUpdateInput!): Commune!
  deleteCommune(where: CommuneWhereUniqueInput!): Commune
  deleteManyCommunes(where: CommuneWhereInput): BatchPayload!
  createCountry(data: CountryCreateInput!): Country!
  updateCountry(data: CountryUpdateInput!, where: CountryWhereUniqueInput!): Country
  updateManyCountries(data: CountryUpdateManyMutationInput!, where: CountryWhereInput): BatchPayload!
  upsertCountry(where: CountryWhereUniqueInput!, create: CountryCreateInput!, update: CountryUpdateInput!): Country!
  deleteCountry(where: CountryWhereUniqueInput!): Country
  deleteManyCountries(where: CountryWhereInput): BatchPayload!
  createCreditCardInformation(data: CreditCardInformationCreateInput!): CreditCardInformation!
  updateCreditCardInformation(data: CreditCardInformationUpdateInput!, where: CreditCardInformationWhereUniqueInput!): CreditCardInformation
  updateManyCreditCardInformations(data: CreditCardInformationUpdateManyMutationInput!, where: CreditCardInformationWhereInput): BatchPayload!
  upsertCreditCardInformation(where: CreditCardInformationWhereUniqueInput!, create: CreditCardInformationCreateInput!, update: CreditCardInformationUpdateInput!): CreditCardInformation!
  deleteCreditCardInformation(where: CreditCardInformationWhereUniqueInput!): CreditCardInformation
  deleteManyCreditCardInformations(where: CreditCardInformationWhereInput): BatchPayload!
  createHouse(data: HouseCreateInput!): House!
  updateHouse(data: HouseUpdateInput!, where: HouseWhereUniqueInput!): House
  updateManyHouses(data: HouseUpdateManyMutationInput!, where: HouseWhereInput): BatchPayload!
  upsertHouse(where: HouseWhereUniqueInput!, create: HouseCreateInput!, update: HouseUpdateInput!): House!
  deleteHouse(where: HouseWhereUniqueInput!): House
  deleteManyHouses(where: HouseWhereInput): BatchPayload!
  createHouse_Favorited(data: House_FavoritedCreateInput!): House_Favorited!
  updateHouse_Favorited(data: House_FavoritedUpdateInput!, where: House_FavoritedWhereUniqueInput!): House_Favorited
  upsertHouse_Favorited(where: House_FavoritedWhereUniqueInput!, create: House_FavoritedCreateInput!, update: House_FavoritedUpdateInput!): House_Favorited!
  deleteHouse_Favorited(where: House_FavoritedWhereUniqueInput!): House_Favorited
  deleteManyHouse_Favoriteds(where: House_FavoritedWhereInput): BatchPayload!
  createLocation(data: LocationCreateInput!): Location!
  updateLocation(data: LocationUpdateInput!, where: LocationWhereUniqueInput!): Location
  updateManyLocations(data: LocationUpdateManyMutationInput!, where: LocationWhereInput): BatchPayload!
  upsertLocation(where: LocationWhereUniqueInput!, create: LocationCreateInput!, update: LocationUpdateInput!): Location!
  deleteLocation(where: LocationWhereUniqueInput!): Location
  deleteManyLocations(where: LocationWhereInput): BatchPayload!
  createNegotiation(data: NegotiationCreateInput!): Negotiation!
  updateNegotiation(data: NegotiationUpdateInput!, where: NegotiationWhereUniqueInput!): Negotiation
  updateManyNegotiations(data: NegotiationUpdateManyMutationInput!, where: NegotiationWhereInput): BatchPayload!
  upsertNegotiation(where: NegotiationWhereUniqueInput!, create: NegotiationCreateInput!, update: NegotiationUpdateInput!): Negotiation!
  deleteNegotiation(where: NegotiationWhereUniqueInput!): Negotiation
  deleteManyNegotiations(where: NegotiationWhereInput): BatchPayload!
  createNotification(data: NotificationCreateInput!): Notification!
  updateNotification(data: NotificationUpdateInput!, where: NotificationWhereUniqueInput!): Notification
  updateManyNotifications(data: NotificationUpdateManyMutationInput!, where: NotificationWhereInput): BatchPayload!
  upsertNotification(where: NotificationWhereUniqueInput!, create: NotificationCreateInput!, update: NotificationUpdateInput!): Notification!
  deleteNotification(where: NotificationWhereUniqueInput!): Notification
  deleteManyNotifications(where: NotificationWhereInput): BatchPayload!
  createPaymentAccount(data: PaymentAccountCreateInput!): PaymentAccount!
  updatePaymentAccount(data: PaymentAccountUpdateInput!, where: PaymentAccountWhereUniqueInput!): PaymentAccount
  updateManyPaymentAccounts(data: PaymentAccountUpdateManyMutationInput!, where: PaymentAccountWhereInput): BatchPayload!
  upsertPaymentAccount(where: PaymentAccountWhereUniqueInput!, create: PaymentAccountCreateInput!, update: PaymentAccountUpdateInput!): PaymentAccount!
  deletePaymentAccount(where: PaymentAccountWhereUniqueInput!): PaymentAccount
  deleteManyPaymentAccounts(where: PaymentAccountWhereInput): BatchPayload!
  createPaymentHouse(data: PaymentHouseCreateInput!): PaymentHouse!
  updatePaymentHouse(data: PaymentHouseUpdateInput!, where: PaymentHouseWhereUniqueInput!): PaymentHouse
  updateManyPaymentHouses(data: PaymentHouseUpdateManyMutationInput!, where: PaymentHouseWhereInput): BatchPayload!
  upsertPaymentHouse(where: PaymentHouseWhereUniqueInput!, create: PaymentHouseCreateInput!, update: PaymentHouseUpdateInput!): PaymentHouse!
  deletePaymentHouse(where: PaymentHouseWhereUniqueInput!): PaymentHouse
  deleteManyPaymentHouses(where: PaymentHouseWhereInput): BatchPayload!
  createPaymentLanlordInfo(data: PaymentLanlordInfoCreateInput!): PaymentLanlordInfo!
  updatePaymentLanlordInfo(data: PaymentLanlordInfoUpdateInput!, where: PaymentLanlordInfoWhereUniqueInput!): PaymentLanlordInfo
  updateManyPaymentLanlordInfoes(data: PaymentLanlordInfoUpdateManyMutationInput!, where: PaymentLanlordInfoWhereInput): BatchPayload!
  upsertPaymentLanlordInfo(where: PaymentLanlordInfoWhereUniqueInput!, create: PaymentLanlordInfoCreateInput!, update: PaymentLanlordInfoUpdateInput!): PaymentLanlordInfo!
  deletePaymentLanlordInfo(where: PaymentLanlordInfoWhereUniqueInput!): PaymentLanlordInfo
  deleteManyPaymentLanlordInfoes(where: PaymentLanlordInfoWhereInput): BatchPayload!
  createPaypalInformation(data: PaypalInformationCreateInput!): PaypalInformation!
  updatePaypalInformation(data: PaypalInformationUpdateInput!, where: PaypalInformationWhereUniqueInput!): PaypalInformation
  updateManyPaypalInformations(data: PaypalInformationUpdateManyMutationInput!, where: PaypalInformationWhereInput): BatchPayload!
  upsertPaypalInformation(where: PaypalInformationWhereUniqueInput!, create: PaypalInformationCreateInput!, update: PaypalInformationUpdateInput!): PaypalInformation!
  deletePaypalInformation(where: PaypalInformationWhereUniqueInput!): PaypalInformation
  deleteManyPaypalInformations(where: PaypalInformationWhereInput): BatchPayload!
  createPicture(data: PictureCreateInput!): Picture!
  updatePicture(data: PictureUpdateInput!, where: PictureWhereUniqueInput!): Picture
  updateManyPictures(data: PictureUpdateManyMutationInput!, where: PictureWhereInput): BatchPayload!
  upsertPicture(where: PictureWhereUniqueInput!, create: PictureCreateInput!, update: PictureUpdateInput!): Picture!
  deletePicture(where: PictureWhereUniqueInput!): Picture
  deleteManyPictures(where: PictureWhereInput): BatchPayload!
  createPricing(data: PricingCreateInput!): Pricing!
  updatePricing(data: PricingUpdateInput!, where: PricingWhereUniqueInput!): Pricing
  updateManyPricings(data: PricingUpdateManyMutationInput!, where: PricingWhereInput): BatchPayload!
  upsertPricing(where: PricingWhereUniqueInput!, create: PricingCreateInput!, update: PricingUpdateInput!): Pricing!
  deletePricing(where: PricingWhereUniqueInput!): Pricing
  deleteManyPricings(where: PricingWhereInput): BatchPayload!
  createReview(data: ReviewCreateInput!): Review!
  updateReview(data: ReviewUpdateInput!, where: ReviewWhereUniqueInput!): Review
  updateManyReviews(data: ReviewUpdateManyMutationInput!, where: ReviewWhereInput): BatchPayload!
  upsertReview(where: ReviewWhereUniqueInput!, create: ReviewCreateInput!, update: ReviewUpdateInput!): Review!
  deleteReview(where: ReviewWhereUniqueInput!): Review
  deleteManyReviews(where: ReviewWhereInput): BatchPayload!
  createRoom(data: RoomCreateInput!): Room!
  updateRoom(data: RoomUpdateInput!, where: RoomWhereUniqueInput!): Room
  updateManyRooms(data: RoomUpdateManyMutationInput!, where: RoomWhereInput): BatchPayload!
  upsertRoom(where: RoomWhereUniqueInput!, create: RoomCreateInput!, update: RoomUpdateInput!): Room!
  deleteRoom(where: RoomWhereUniqueInput!): Room
  deleteManyRooms(where: RoomWhereInput): BatchPayload!
  createState(data: StateCreateInput!): State!
  updateState(data: StateUpdateInput!, where: StateWhereUniqueInput!): State
  updateManyStates(data: StateUpdateManyMutationInput!, where: StateWhereInput): BatchPayload!
  upsertState(where: StateWhereUniqueInput!, create: StateCreateInput!, update: StateUpdateInput!): State!
  deleteState(where: StateWhereUniqueInput!): State
  deleteManyStates(where: StateWhereInput): BatchPayload!
  createUser(data: UserCreateInput!): User!
  updateUser(data: UserUpdateInput!, where: UserWhereUniqueInput!): User
  updateManyUsers(data: UserUpdateManyMutationInput!, where: UserWhereInput): BatchPayload!
  upsertUser(where: UserWhereUniqueInput!, create: UserCreateInput!, update: UserUpdateInput!): User!
  deleteUser(where: UserWhereUniqueInput!): User
  deleteManyUsers(where: UserWhereInput): BatchPayload!
  createVideo(data: VideoCreateInput!): Video!
  updateVideo(data: VideoUpdateInput!, where: VideoWhereUniqueInput!): Video
  updateManyVideos(data: VideoUpdateManyMutationInput!, where: VideoWhereInput): BatchPayload!
  upsertVideo(where: VideoWhereUniqueInput!, create: VideoCreateInput!, update: VideoUpdateInput!): Video!
  deleteVideo(where: VideoWhereUniqueInput!): Video
  deleteManyVideos(where: VideoWhereInput): BatchPayload!
  createViews(data: ViewsCreateInput!): Views!
  updateViews(data: ViewsUpdateInput!, where: ViewsWhereUniqueInput!): Views
  updateManyViewses(data: ViewsUpdateManyMutationInput!, where: ViewsWhereInput): BatchPayload!
  upsertViews(where: ViewsWhereUniqueInput!, create: ViewsCreateInput!, update: ViewsUpdateInput!): Views!
  deleteViews(where: ViewsWhereUniqueInput!): Views
  deleteManyViewses(where: ViewsWhereInput): BatchPayload!
}

enum MutationType {
  CREATED
  UPDATED
  DELETED
}

type Negotiation {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  negotiator: User!
  House: House!
  offer: Float!
  status: NEGOTIATION_TYPE
}

enum NEGOTIATION_TYPE {
  PENDING
  ACCEPTED
  REFUSED
}

type NegotiationConnection {
  pageInfo: PageInfo!
  edges: [NegotiationEdge]!
  aggregate: AggregateNegotiation!
}

input NegotiationCreateInput {
  id: ID
  negotiator: UserCreateOneInput!
  House: HouseCreateOneInput!
  offer: Float!
  status: NEGOTIATION_TYPE
}

type NegotiationEdge {
  node: Negotiation!
  cursor: String!
}

enum NegotiationOrderByInput {
  id_ASC
  id_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
  offer_ASC
  offer_DESC
  status_ASC
  status_DESC
}

type NegotiationPreviousValues {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  offer: Float!
  status: NEGOTIATION_TYPE
}

type NegotiationSubscriptionPayload {
  mutation: MutationType!
  node: Negotiation
  updatedFields: [String!]
  previousValues: NegotiationPreviousValues
}

input NegotiationSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: NegotiationWhereInput
  AND: [NegotiationSubscriptionWhereInput!]
  OR: [NegotiationSubscriptionWhereInput!]
  NOT: [NegotiationSubscriptionWhereInput!]
}

input NegotiationUpdateInput {
  negotiator: UserUpdateOneRequiredInput
  House: HouseUpdateOneRequiredInput
  offer: Float
  status: NEGOTIATION_TYPE
}

input NegotiationUpdateManyMutationInput {
  offer: Float
  status: NEGOTIATION_TYPE
}

input NegotiationWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  negotiator: UserWhereInput
  House: HouseWhereInput
  offer: Float
  offer_not: Float
  offer_in: [Float!]
  offer_not_in: [Float!]
  offer_lt: Float
  offer_lte: Float
  offer_gt: Float
  offer_gte: Float
  status: NEGOTIATION_TYPE
  status_not: NEGOTIATION_TYPE
  status_in: [NEGOTIATION_TYPE!]
  status_not_in: [NEGOTIATION_TYPE!]
  AND: [NegotiationWhereInput!]
  OR: [NegotiationWhereInput!]
  NOT: [NegotiationWhereInput!]
}

input NegotiationWhereUniqueInput {
  id: ID
}

interface Node {
  id: ID!
}

type Notification {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  type: NOTIFICATION_TYPE
  user: User!
  link: String!
  readDate: DateTime!
}

enum NOTIFICATION_TYPE {
  OFFER
  INSTANT_BOOK
  RESPONSIVENESS
  NEW_AMENITIES
  HOUSE_RULES
}

type NotificationConnection {
  pageInfo: PageInfo!
  edges: [NotificationEdge]!
  aggregate: AggregateNotification!
}

input NotificationCreateInput {
  id: ID
  type: NOTIFICATION_TYPE
  user: UserCreateOneWithoutNotificationsInput!
  link: String!
  readDate: DateTime!
}

input NotificationCreateManyWithoutUserInput {
  create: [NotificationCreateWithoutUserInput!]
  connect: [NotificationWhereUniqueInput!]
}

input NotificationCreateWithoutUserInput {
  id: ID
  type: NOTIFICATION_TYPE
  link: String!
  readDate: DateTime!
}

type NotificationEdge {
  node: Notification!
  cursor: String!
}

enum NotificationOrderByInput {
  id_ASC
  id_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
  type_ASC
  type_DESC
  link_ASC
  link_DESC
  readDate_ASC
  readDate_DESC
}

type NotificationPreviousValues {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  type: NOTIFICATION_TYPE
  link: String!
  readDate: DateTime!
}

input NotificationScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  type: NOTIFICATION_TYPE
  type_not: NOTIFICATION_TYPE
  type_in: [NOTIFICATION_TYPE!]
  type_not_in: [NOTIFICATION_TYPE!]
  link: String
  link_not: String
  link_in: [String!]
  link_not_in: [String!]
  link_lt: String
  link_lte: String
  link_gt: String
  link_gte: String
  link_contains: String
  link_not_contains: String
  link_starts_with: String
  link_not_starts_with: String
  link_ends_with: String
  link_not_ends_with: String
  readDate: DateTime
  readDate_not: DateTime
  readDate_in: [DateTime!]
  readDate_not_in: [DateTime!]
  readDate_lt: DateTime
  readDate_lte: DateTime
  readDate_gt: DateTime
  readDate_gte: DateTime
  AND: [NotificationScalarWhereInput!]
  OR: [NotificationScalarWhereInput!]
  NOT: [NotificationScalarWhereInput!]
}

type NotificationSubscriptionPayload {
  mutation: MutationType!
  node: Notification
  updatedFields: [String!]
  previousValues: NotificationPreviousValues
}

input NotificationSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: NotificationWhereInput
  AND: [NotificationSubscriptionWhereInput!]
  OR: [NotificationSubscriptionWhereInput!]
  NOT: [NotificationSubscriptionWhereInput!]
}

input NotificationUpdateInput {
  type: NOTIFICATION_TYPE
  user: UserUpdateOneRequiredWithoutNotificationsInput
  link: String
  readDate: DateTime
}

input NotificationUpdateManyDataInput {
  type: NOTIFICATION_TYPE
  link: String
  readDate: DateTime
}

input NotificationUpdateManyMutationInput {
  type: NOTIFICATION_TYPE
  link: String
  readDate: DateTime
}

input NotificationUpdateManyWithoutUserInput {
  create: [NotificationCreateWithoutUserInput!]
  delete: [NotificationWhereUniqueInput!]
  connect: [NotificationWhereUniqueInput!]
  set: [NotificationWhereUniqueInput!]
  disconnect: [NotificationWhereUniqueInput!]
  update: [NotificationUpdateWithWhereUniqueWithoutUserInput!]
  upsert: [NotificationUpsertWithWhereUniqueWithoutUserInput!]
  deleteMany: [NotificationScalarWhereInput!]
  updateMany: [NotificationUpdateManyWithWhereNestedInput!]
}

input NotificationUpdateManyWithWhereNestedInput {
  where: NotificationScalarWhereInput!
  data: NotificationUpdateManyDataInput!
}

input NotificationUpdateWithoutUserDataInput {
  type: NOTIFICATION_TYPE
  link: String
  readDate: DateTime
}

input NotificationUpdateWithWhereUniqueWithoutUserInput {
  where: NotificationWhereUniqueInput!
  data: NotificationUpdateWithoutUserDataInput!
}

input NotificationUpsertWithWhereUniqueWithoutUserInput {
  where: NotificationWhereUniqueInput!
  update: NotificationUpdateWithoutUserDataInput!
  create: NotificationCreateWithoutUserInput!
}

input NotificationWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  type: NOTIFICATION_TYPE
  type_not: NOTIFICATION_TYPE
  type_in: [NOTIFICATION_TYPE!]
  type_not_in: [NOTIFICATION_TYPE!]
  user: UserWhereInput
  link: String
  link_not: String
  link_in: [String!]
  link_not_in: [String!]
  link_lt: String
  link_lte: String
  link_gt: String
  link_gte: String
  link_contains: String
  link_not_contains: String
  link_starts_with: String
  link_not_starts_with: String
  link_ends_with: String
  link_not_ends_with: String
  readDate: DateTime
  readDate_not: DateTime
  readDate_in: [DateTime!]
  readDate_not_in: [DateTime!]
  readDate_lt: DateTime
  readDate_lte: DateTime
  readDate_gt: DateTime
  readDate_gte: DateTime
  AND: [NotificationWhereInput!]
  OR: [NotificationWhereInput!]
  NOT: [NotificationWhereInput!]
}

input NotificationWhereUniqueInput {
  id: ID
}

type PageInfo {
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String
  endCursor: String
}

enum PAYMENT_PROVIDER {
  PAYPAL
  CREDIT_CARD
}

type PaymentAccount {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  type: PAYMENT_PROVIDER
  user: User!
  payments(where: PaymentHouseWhereInput, orderBy: PaymentHouseOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [PaymentHouse!]
  paypal: PaypalInformation
  creditcard: CreditCardInformation
}

type PaymentAccountConnection {
  pageInfo: PageInfo!
  edges: [PaymentAccountEdge]!
  aggregate: AggregatePaymentAccount!
}

input PaymentAccountCreateInput {
  id: ID
  type: PAYMENT_PROVIDER
  user: UserCreateOneInput!
  payments: PaymentHouseCreateManyWithoutPaymentMethodInput
  paypal: PaypalInformationCreateOneWithoutPaymentAccountInput
  creditcard: CreditCardInformationCreateOneWithoutPaymentAccountInput
}

input PaymentAccountCreateOneWithoutCreditcardInput {
  create: PaymentAccountCreateWithoutCreditcardInput
  connect: PaymentAccountWhereUniqueInput
}

input PaymentAccountCreateOneWithoutPaymentsInput {
  create: PaymentAccountCreateWithoutPaymentsInput
  connect: PaymentAccountWhereUniqueInput
}

input PaymentAccountCreateOneWithoutPaypalInput {
  create: PaymentAccountCreateWithoutPaypalInput
  connect: PaymentAccountWhereUniqueInput
}

input PaymentAccountCreateWithoutCreditcardInput {
  id: ID
  type: PAYMENT_PROVIDER
  user: UserCreateOneInput!
  payments: PaymentHouseCreateManyWithoutPaymentMethodInput
  paypal: PaypalInformationCreateOneWithoutPaymentAccountInput
}

input PaymentAccountCreateWithoutPaymentsInput {
  id: ID
  type: PAYMENT_PROVIDER
  user: UserCreateOneInput!
  paypal: PaypalInformationCreateOneWithoutPaymentAccountInput
  creditcard: CreditCardInformationCreateOneWithoutPaymentAccountInput
}

input PaymentAccountCreateWithoutPaypalInput {
  id: ID
  type: PAYMENT_PROVIDER
  user: UserCreateOneInput!
  payments: PaymentHouseCreateManyWithoutPaymentMethodInput
  creditcard: CreditCardInformationCreateOneWithoutPaymentAccountInput
}

type PaymentAccountEdge {
  node: PaymentAccount!
  cursor: String!
}

enum PaymentAccountOrderByInput {
  id_ASC
  id_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
  type_ASC
  type_DESC
}

type PaymentAccountPreviousValues {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  type: PAYMENT_PROVIDER
}

type PaymentAccountSubscriptionPayload {
  mutation: MutationType!
  node: PaymentAccount
  updatedFields: [String!]
  previousValues: PaymentAccountPreviousValues
}

input PaymentAccountSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: PaymentAccountWhereInput
  AND: [PaymentAccountSubscriptionWhereInput!]
  OR: [PaymentAccountSubscriptionWhereInput!]
  NOT: [PaymentAccountSubscriptionWhereInput!]
}

input PaymentAccountUpdateInput {
  type: PAYMENT_PROVIDER
  user: UserUpdateOneRequiredInput
  payments: PaymentHouseUpdateManyWithoutPaymentMethodInput
  paypal: PaypalInformationUpdateOneWithoutPaymentAccountInput
  creditcard: CreditCardInformationUpdateOneWithoutPaymentAccountInput
}

input PaymentAccountUpdateManyMutationInput {
  type: PAYMENT_PROVIDER
}

input PaymentAccountUpdateOneRequiredWithoutPaymentsInput {
  create: PaymentAccountCreateWithoutPaymentsInput
  update: PaymentAccountUpdateWithoutPaymentsDataInput
  upsert: PaymentAccountUpsertWithoutPaymentsInput
  connect: PaymentAccountWhereUniqueInput
}

input PaymentAccountUpdateOneRequiredWithoutPaypalInput {
  create: PaymentAccountCreateWithoutPaypalInput
  update: PaymentAccountUpdateWithoutPaypalDataInput
  upsert: PaymentAccountUpsertWithoutPaypalInput
  connect: PaymentAccountWhereUniqueInput
}

input PaymentAccountUpdateOneWithoutCreditcardInput {
  create: PaymentAccountCreateWithoutCreditcardInput
  update: PaymentAccountUpdateWithoutCreditcardDataInput
  upsert: PaymentAccountUpsertWithoutCreditcardInput
  delete: Boolean
  disconnect: Boolean
  connect: PaymentAccountWhereUniqueInput
}

input PaymentAccountUpdateWithoutCreditcardDataInput {
  type: PAYMENT_PROVIDER
  user: UserUpdateOneRequiredInput
  payments: PaymentHouseUpdateManyWithoutPaymentMethodInput
  paypal: PaypalInformationUpdateOneWithoutPaymentAccountInput
}

input PaymentAccountUpdateWithoutPaymentsDataInput {
  type: PAYMENT_PROVIDER
  user: UserUpdateOneRequiredInput
  paypal: PaypalInformationUpdateOneWithoutPaymentAccountInput
  creditcard: CreditCardInformationUpdateOneWithoutPaymentAccountInput
}

input PaymentAccountUpdateWithoutPaypalDataInput {
  type: PAYMENT_PROVIDER
  user: UserUpdateOneRequiredInput
  payments: PaymentHouseUpdateManyWithoutPaymentMethodInput
  creditcard: CreditCardInformationUpdateOneWithoutPaymentAccountInput
}

input PaymentAccountUpsertWithoutCreditcardInput {
  update: PaymentAccountUpdateWithoutCreditcardDataInput!
  create: PaymentAccountCreateWithoutCreditcardInput!
}

input PaymentAccountUpsertWithoutPaymentsInput {
  update: PaymentAccountUpdateWithoutPaymentsDataInput!
  create: PaymentAccountCreateWithoutPaymentsInput!
}

input PaymentAccountUpsertWithoutPaypalInput {
  update: PaymentAccountUpdateWithoutPaypalDataInput!
  create: PaymentAccountCreateWithoutPaypalInput!
}

input PaymentAccountWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  type: PAYMENT_PROVIDER
  type_not: PAYMENT_PROVIDER
  type_in: [PAYMENT_PROVIDER!]
  type_not_in: [PAYMENT_PROVIDER!]
  user: UserWhereInput
  payments_every: PaymentHouseWhereInput
  payments_some: PaymentHouseWhereInput
  payments_none: PaymentHouseWhereInput
  paypal: PaypalInformationWhereInput
  creditcard: CreditCardInformationWhereInput
  AND: [PaymentAccountWhereInput!]
  OR: [PaymentAccountWhereInput!]
  NOT: [PaymentAccountWhereInput!]
}

input PaymentAccountWhereUniqueInput {
  id: ID
}

type PaymentHouse {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  totalPrice: Float!
  booking: Booking!
  paymentMethod: PaymentAccount!
}

type PaymentHouseConnection {
  pageInfo: PageInfo!
  edges: [PaymentHouseEdge]!
  aggregate: AggregatePaymentHouse!
}

input PaymentHouseCreateInput {
  id: ID
  totalPrice: Float!
  booking: BookingCreateOneWithoutPaymentInput!
  paymentMethod: PaymentAccountCreateOneWithoutPaymentsInput!
}

input PaymentHouseCreateManyWithoutPaymentMethodInput {
  create: [PaymentHouseCreateWithoutPaymentMethodInput!]
  connect: [PaymentHouseWhereUniqueInput!]
}

input PaymentHouseCreateOneWithoutBookingInput {
  create: PaymentHouseCreateWithoutBookingInput
  connect: PaymentHouseWhereUniqueInput
}

input PaymentHouseCreateWithoutBookingInput {
  id: ID
  totalPrice: Float!
  paymentMethod: PaymentAccountCreateOneWithoutPaymentsInput!
}

input PaymentHouseCreateWithoutPaymentMethodInput {
  id: ID
  totalPrice: Float!
  booking: BookingCreateOneWithoutPaymentInput!
}

type PaymentHouseEdge {
  node: PaymentHouse!
  cursor: String!
}

enum PaymentHouseOrderByInput {
  id_ASC
  id_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
  totalPrice_ASC
  totalPrice_DESC
}

type PaymentHousePreviousValues {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  totalPrice: Float!
}

input PaymentHouseScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  totalPrice: Float
  totalPrice_not: Float
  totalPrice_in: [Float!]
  totalPrice_not_in: [Float!]
  totalPrice_lt: Float
  totalPrice_lte: Float
  totalPrice_gt: Float
  totalPrice_gte: Float
  AND: [PaymentHouseScalarWhereInput!]
  OR: [PaymentHouseScalarWhereInput!]
  NOT: [PaymentHouseScalarWhereInput!]
}

type PaymentHouseSubscriptionPayload {
  mutation: MutationType!
  node: PaymentHouse
  updatedFields: [String!]
  previousValues: PaymentHousePreviousValues
}

input PaymentHouseSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: PaymentHouseWhereInput
  AND: [PaymentHouseSubscriptionWhereInput!]
  OR: [PaymentHouseSubscriptionWhereInput!]
  NOT: [PaymentHouseSubscriptionWhereInput!]
}

input PaymentHouseUpdateInput {
  totalPrice: Float
  booking: BookingUpdateOneRequiredWithoutPaymentInput
  paymentMethod: PaymentAccountUpdateOneRequiredWithoutPaymentsInput
}

input PaymentHouseUpdateManyDataInput {
  totalPrice: Float
}

input PaymentHouseUpdateManyMutationInput {
  totalPrice: Float
}

input PaymentHouseUpdateManyWithoutPaymentMethodInput {
  create: [PaymentHouseCreateWithoutPaymentMethodInput!]
  delete: [PaymentHouseWhereUniqueInput!]
  connect: [PaymentHouseWhereUniqueInput!]
  set: [PaymentHouseWhereUniqueInput!]
  disconnect: [PaymentHouseWhereUniqueInput!]
  update: [PaymentHouseUpdateWithWhereUniqueWithoutPaymentMethodInput!]
  upsert: [PaymentHouseUpsertWithWhereUniqueWithoutPaymentMethodInput!]
  deleteMany: [PaymentHouseScalarWhereInput!]
  updateMany: [PaymentHouseUpdateManyWithWhereNestedInput!]
}

input PaymentHouseUpdateManyWithWhereNestedInput {
  where: PaymentHouseScalarWhereInput!
  data: PaymentHouseUpdateManyDataInput!
}

input PaymentHouseUpdateOneRequiredWithoutBookingInput {
  create: PaymentHouseCreateWithoutBookingInput
  update: PaymentHouseUpdateWithoutBookingDataInput
  upsert: PaymentHouseUpsertWithoutBookingInput
  connect: PaymentHouseWhereUniqueInput
}

input PaymentHouseUpdateWithoutBookingDataInput {
  totalPrice: Float
  paymentMethod: PaymentAccountUpdateOneRequiredWithoutPaymentsInput
}

input PaymentHouseUpdateWithoutPaymentMethodDataInput {
  totalPrice: Float
  booking: BookingUpdateOneRequiredWithoutPaymentInput
}

input PaymentHouseUpdateWithWhereUniqueWithoutPaymentMethodInput {
  where: PaymentHouseWhereUniqueInput!
  data: PaymentHouseUpdateWithoutPaymentMethodDataInput!
}

input PaymentHouseUpsertWithoutBookingInput {
  update: PaymentHouseUpdateWithoutBookingDataInput!
  create: PaymentHouseCreateWithoutBookingInput!
}

input PaymentHouseUpsertWithWhereUniqueWithoutPaymentMethodInput {
  where: PaymentHouseWhereUniqueInput!
  update: PaymentHouseUpdateWithoutPaymentMethodDataInput!
  create: PaymentHouseCreateWithoutPaymentMethodInput!
}

input PaymentHouseWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  totalPrice: Float
  totalPrice_not: Float
  totalPrice_in: [Float!]
  totalPrice_not_in: [Float!]
  totalPrice_lt: Float
  totalPrice_lte: Float
  totalPrice_gt: Float
  totalPrice_gte: Float
  booking: BookingWhereInput
  paymentMethod: PaymentAccountWhereInput
  AND: [PaymentHouseWhereInput!]
  OR: [PaymentHouseWhereInput!]
  NOT: [PaymentHouseWhereInput!]
}

input PaymentHouseWhereUniqueInput {
  id: ID
}

type PaymentLanlordInfo {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  totalPrice: Float!
  client: User!
  House: House!
  moncashTransactId: String!
}

type PaymentLanlordInfoConnection {
  pageInfo: PageInfo!
  edges: [PaymentLanlordInfoEdge]!
  aggregate: AggregatePaymentLanlordInfo!
}

input PaymentLanlordInfoCreateInput {
  id: ID
  totalPrice: Float!
  client: UserCreateOneWithoutPaidContactsInput!
  House: HouseCreateOneWithoutContactInfoPaymentsInput!
  moncashTransactId: String!
}

input PaymentLanlordInfoCreateManyWithoutClientInput {
  create: [PaymentLanlordInfoCreateWithoutClientInput!]
  connect: [PaymentLanlordInfoWhereUniqueInput!]
}

input PaymentLanlordInfoCreateManyWithoutHouseInput {
  create: [PaymentLanlordInfoCreateWithoutHouseInput!]
  connect: [PaymentLanlordInfoWhereUniqueInput!]
}

input PaymentLanlordInfoCreateWithoutClientInput {
  id: ID
  totalPrice: Float!
  House: HouseCreateOneWithoutContactInfoPaymentsInput!
  moncashTransactId: String!
}

input PaymentLanlordInfoCreateWithoutHouseInput {
  id: ID
  totalPrice: Float!
  client: UserCreateOneWithoutPaidContactsInput!
  moncashTransactId: String!
}

type PaymentLanlordInfoEdge {
  node: PaymentLanlordInfo!
  cursor: String!
}

enum PaymentLanlordInfoOrderByInput {
  id_ASC
  id_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
  totalPrice_ASC
  totalPrice_DESC
  moncashTransactId_ASC
  moncashTransactId_DESC
}

type PaymentLanlordInfoPreviousValues {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  totalPrice: Float!
  moncashTransactId: String!
}

input PaymentLanlordInfoScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  totalPrice: Float
  totalPrice_not: Float
  totalPrice_in: [Float!]
  totalPrice_not_in: [Float!]
  totalPrice_lt: Float
  totalPrice_lte: Float
  totalPrice_gt: Float
  totalPrice_gte: Float
  moncashTransactId: String
  moncashTransactId_not: String
  moncashTransactId_in: [String!]
  moncashTransactId_not_in: [String!]
  moncashTransactId_lt: String
  moncashTransactId_lte: String
  moncashTransactId_gt: String
  moncashTransactId_gte: String
  moncashTransactId_contains: String
  moncashTransactId_not_contains: String
  moncashTransactId_starts_with: String
  moncashTransactId_not_starts_with: String
  moncashTransactId_ends_with: String
  moncashTransactId_not_ends_with: String
  AND: [PaymentLanlordInfoScalarWhereInput!]
  OR: [PaymentLanlordInfoScalarWhereInput!]
  NOT: [PaymentLanlordInfoScalarWhereInput!]
}

type PaymentLanlordInfoSubscriptionPayload {
  mutation: MutationType!
  node: PaymentLanlordInfo
  updatedFields: [String!]
  previousValues: PaymentLanlordInfoPreviousValues
}

input PaymentLanlordInfoSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: PaymentLanlordInfoWhereInput
  AND: [PaymentLanlordInfoSubscriptionWhereInput!]
  OR: [PaymentLanlordInfoSubscriptionWhereInput!]
  NOT: [PaymentLanlordInfoSubscriptionWhereInput!]
}

input PaymentLanlordInfoUpdateInput {
  totalPrice: Float
  client: UserUpdateOneRequiredWithoutPaidContactsInput
  House: HouseUpdateOneRequiredWithoutContactInfoPaymentsInput
  moncashTransactId: String
}

input PaymentLanlordInfoUpdateManyDataInput {
  totalPrice: Float
  moncashTransactId: String
}

input PaymentLanlordInfoUpdateManyMutationInput {
  totalPrice: Float
  moncashTransactId: String
}

input PaymentLanlordInfoUpdateManyWithoutClientInput {
  create: [PaymentLanlordInfoCreateWithoutClientInput!]
  delete: [PaymentLanlordInfoWhereUniqueInput!]
  connect: [PaymentLanlordInfoWhereUniqueInput!]
  set: [PaymentLanlordInfoWhereUniqueInput!]
  disconnect: [PaymentLanlordInfoWhereUniqueInput!]
  update: [PaymentLanlordInfoUpdateWithWhereUniqueWithoutClientInput!]
  upsert: [PaymentLanlordInfoUpsertWithWhereUniqueWithoutClientInput!]
  deleteMany: [PaymentLanlordInfoScalarWhereInput!]
  updateMany: [PaymentLanlordInfoUpdateManyWithWhereNestedInput!]
}

input PaymentLanlordInfoUpdateManyWithoutHouseInput {
  create: [PaymentLanlordInfoCreateWithoutHouseInput!]
  delete: [PaymentLanlordInfoWhereUniqueInput!]
  connect: [PaymentLanlordInfoWhereUniqueInput!]
  set: [PaymentLanlordInfoWhereUniqueInput!]
  disconnect: [PaymentLanlordInfoWhereUniqueInput!]
  update: [PaymentLanlordInfoUpdateWithWhereUniqueWithoutHouseInput!]
  upsert: [PaymentLanlordInfoUpsertWithWhereUniqueWithoutHouseInput!]
  deleteMany: [PaymentLanlordInfoScalarWhereInput!]
  updateMany: [PaymentLanlordInfoUpdateManyWithWhereNestedInput!]
}

input PaymentLanlordInfoUpdateManyWithWhereNestedInput {
  where: PaymentLanlordInfoScalarWhereInput!
  data: PaymentLanlordInfoUpdateManyDataInput!
}

input PaymentLanlordInfoUpdateWithoutClientDataInput {
  totalPrice: Float
  House: HouseUpdateOneRequiredWithoutContactInfoPaymentsInput
  moncashTransactId: String
}

input PaymentLanlordInfoUpdateWithoutHouseDataInput {
  totalPrice: Float
  client: UserUpdateOneRequiredWithoutPaidContactsInput
  moncashTransactId: String
}

input PaymentLanlordInfoUpdateWithWhereUniqueWithoutClientInput {
  where: PaymentLanlordInfoWhereUniqueInput!
  data: PaymentLanlordInfoUpdateWithoutClientDataInput!
}

input PaymentLanlordInfoUpdateWithWhereUniqueWithoutHouseInput {
  where: PaymentLanlordInfoWhereUniqueInput!
  data: PaymentLanlordInfoUpdateWithoutHouseDataInput!
}

input PaymentLanlordInfoUpsertWithWhereUniqueWithoutClientInput {
  where: PaymentLanlordInfoWhereUniqueInput!
  update: PaymentLanlordInfoUpdateWithoutClientDataInput!
  create: PaymentLanlordInfoCreateWithoutClientInput!
}

input PaymentLanlordInfoUpsertWithWhereUniqueWithoutHouseInput {
  where: PaymentLanlordInfoWhereUniqueInput!
  update: PaymentLanlordInfoUpdateWithoutHouseDataInput!
  create: PaymentLanlordInfoCreateWithoutHouseInput!
}

input PaymentLanlordInfoWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  totalPrice: Float
  totalPrice_not: Float
  totalPrice_in: [Float!]
  totalPrice_not_in: [Float!]
  totalPrice_lt: Float
  totalPrice_lte: Float
  totalPrice_gt: Float
  totalPrice_gte: Float
  client: UserWhereInput
  House: HouseWhereInput
  moncashTransactId: String
  moncashTransactId_not: String
  moncashTransactId_in: [String!]
  moncashTransactId_not_in: [String!]
  moncashTransactId_lt: String
  moncashTransactId_lte: String
  moncashTransactId_gt: String
  moncashTransactId_gte: String
  moncashTransactId_contains: String
  moncashTransactId_not_contains: String
  moncashTransactId_starts_with: String
  moncashTransactId_not_starts_with: String
  moncashTransactId_ends_with: String
  moncashTransactId_not_ends_with: String
  AND: [PaymentLanlordInfoWhereInput!]
  OR: [PaymentLanlordInfoWhereInput!]
  NOT: [PaymentLanlordInfoWhereInput!]
}

input PaymentLanlordInfoWhereUniqueInput {
  id: ID
}

type PaypalInformation {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  email: String!
  paymentAccount: PaymentAccount!
}

type PaypalInformationConnection {
  pageInfo: PageInfo!
  edges: [PaypalInformationEdge]!
  aggregate: AggregatePaypalInformation!
}

input PaypalInformationCreateInput {
  id: ID
  email: String!
  paymentAccount: PaymentAccountCreateOneWithoutPaypalInput!
}

input PaypalInformationCreateOneWithoutPaymentAccountInput {
  create: PaypalInformationCreateWithoutPaymentAccountInput
  connect: PaypalInformationWhereUniqueInput
}

input PaypalInformationCreateWithoutPaymentAccountInput {
  id: ID
  email: String!
}

type PaypalInformationEdge {
  node: PaypalInformation!
  cursor: String!
}

enum PaypalInformationOrderByInput {
  id_ASC
  id_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
  email_ASC
  email_DESC
}

type PaypalInformationPreviousValues {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  email: String!
}

type PaypalInformationSubscriptionPayload {
  mutation: MutationType!
  node: PaypalInformation
  updatedFields: [String!]
  previousValues: PaypalInformationPreviousValues
}

input PaypalInformationSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: PaypalInformationWhereInput
  AND: [PaypalInformationSubscriptionWhereInput!]
  OR: [PaypalInformationSubscriptionWhereInput!]
  NOT: [PaypalInformationSubscriptionWhereInput!]
}

input PaypalInformationUpdateInput {
  email: String
  paymentAccount: PaymentAccountUpdateOneRequiredWithoutPaypalInput
}

input PaypalInformationUpdateManyMutationInput {
  email: String
}

input PaypalInformationUpdateOneWithoutPaymentAccountInput {
  create: PaypalInformationCreateWithoutPaymentAccountInput
  update: PaypalInformationUpdateWithoutPaymentAccountDataInput
  upsert: PaypalInformationUpsertWithoutPaymentAccountInput
  delete: Boolean
  disconnect: Boolean
  connect: PaypalInformationWhereUniqueInput
}

input PaypalInformationUpdateWithoutPaymentAccountDataInput {
  email: String
}

input PaypalInformationUpsertWithoutPaymentAccountInput {
  update: PaypalInformationUpdateWithoutPaymentAccountDataInput!
  create: PaypalInformationCreateWithoutPaymentAccountInput!
}

input PaypalInformationWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  email: String
  email_not: String
  email_in: [String!]
  email_not_in: [String!]
  email_lt: String
  email_lte: String
  email_gt: String
  email_gte: String
  email_contains: String
  email_not_contains: String
  email_starts_with: String
  email_not_starts_with: String
  email_ends_with: String
  email_not_ends_with: String
  paymentAccount: PaymentAccountWhereInput
  AND: [PaypalInformationWhereInput!]
  OR: [PaypalInformationWhereInput!]
  NOT: [PaypalInformationWhereInput!]
}

input PaypalInformationWhereUniqueInput {
  id: ID
}

enum Permission {
  STANDARD
  LANDLORD
  ADMIN
  ITEMCREATE
  ITEMUPDATE
  ITEMDELETE
  PERMISSIONUPDATE
}

type Picture {
  id: ID!
  url: String!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type PictureConnection {
  pageInfo: PageInfo!
  edges: [PictureEdge]!
  aggregate: AggregatePicture!
}

input PictureCreateInput {
  id: ID
  url: String!
}

input PictureCreateManyInput {
  create: [PictureCreateInput!]
  connect: [PictureWhereUniqueInput!]
}

input PictureCreateOneInput {
  create: PictureCreateInput
  connect: PictureWhereUniqueInput
}

type PictureEdge {
  node: Picture!
  cursor: String!
}

enum PictureOrderByInput {
  id_ASC
  id_DESC
  url_ASC
  url_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type PicturePreviousValues {
  id: ID!
  url: String!
  createdAt: DateTime!
  updatedAt: DateTime!
}

input PictureScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  url: String
  url_not: String
  url_in: [String!]
  url_not_in: [String!]
  url_lt: String
  url_lte: String
  url_gt: String
  url_gte: String
  url_contains: String
  url_not_contains: String
  url_starts_with: String
  url_not_starts_with: String
  url_ends_with: String
  url_not_ends_with: String
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [PictureScalarWhereInput!]
  OR: [PictureScalarWhereInput!]
  NOT: [PictureScalarWhereInput!]
}

type PictureSubscriptionPayload {
  mutation: MutationType!
  node: Picture
  updatedFields: [String!]
  previousValues: PicturePreviousValues
}

input PictureSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: PictureWhereInput
  AND: [PictureSubscriptionWhereInput!]
  OR: [PictureSubscriptionWhereInput!]
  NOT: [PictureSubscriptionWhereInput!]
}

input PictureUpdateDataInput {
  url: String
}

input PictureUpdateInput {
  url: String
}

input PictureUpdateManyDataInput {
  url: String
}

input PictureUpdateManyInput {
  create: [PictureCreateInput!]
  update: [PictureUpdateWithWhereUniqueNestedInput!]
  upsert: [PictureUpsertWithWhereUniqueNestedInput!]
  delete: [PictureWhereUniqueInput!]
  connect: [PictureWhereUniqueInput!]
  set: [PictureWhereUniqueInput!]
  disconnect: [PictureWhereUniqueInput!]
  deleteMany: [PictureScalarWhereInput!]
  updateMany: [PictureUpdateManyWithWhereNestedInput!]
}

input PictureUpdateManyMutationInput {
  url: String
}

input PictureUpdateManyWithWhereNestedInput {
  where: PictureScalarWhereInput!
  data: PictureUpdateManyDataInput!
}

input PictureUpdateOneInput {
  create: PictureCreateInput
  update: PictureUpdateDataInput
  upsert: PictureUpsertNestedInput
  delete: Boolean
  disconnect: Boolean
  connect: PictureWhereUniqueInput
}

input PictureUpdateWithWhereUniqueNestedInput {
  where: PictureWhereUniqueInput!
  data: PictureUpdateDataInput!
}

input PictureUpsertNestedInput {
  update: PictureUpdateDataInput!
  create: PictureCreateInput!
}

input PictureUpsertWithWhereUniqueNestedInput {
  where: PictureWhereUniqueInput!
  update: PictureUpdateDataInput!
  create: PictureCreateInput!
}

input PictureWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  url: String
  url_not: String
  url_in: [String!]
  url_not_in: [String!]
  url_lt: String
  url_lte: String
  url_gt: String
  url_gte: String
  url_contains: String
  url_not_contains: String
  url_starts_with: String
  url_not_starts_with: String
  url_ends_with: String
  url_not_ends_with: String
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [PictureWhereInput!]
  OR: [PictureWhereInput!]
  NOT: [PictureWhereInput!]
}

input PictureWhereUniqueInput {
  id: ID
}

type Pricing {
  id: ID!
  House: House!
  basePrice: Float
  highestPrice: Float!
  currency: CURRENCY!
  income: Float
  createdAt: DateTime!
  updatedAt: DateTime!
}

type PricingConnection {
  pageInfo: PageInfo!
  edges: [PricingEdge]!
  aggregate: AggregatePricing!
}

input PricingCreateInput {
  id: ID
  House: HouseCreateOneWithoutPricingInput!
  basePrice: Float
  highestPrice: Float!
  currency: CURRENCY!
  income: Float
}

input PricingCreateOneWithoutHouseInput {
  create: PricingCreateWithoutHouseInput
  connect: PricingWhereUniqueInput
}

input PricingCreateWithoutHouseInput {
  id: ID
  basePrice: Float
  highestPrice: Float!
  currency: CURRENCY!
  income: Float
}

type PricingEdge {
  node: Pricing!
  cursor: String!
}

enum PricingOrderByInput {
  id_ASC
  id_DESC
  basePrice_ASC
  basePrice_DESC
  highestPrice_ASC
  highestPrice_DESC
  currency_ASC
  currency_DESC
  income_ASC
  income_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type PricingPreviousValues {
  id: ID!
  basePrice: Float
  highestPrice: Float!
  currency: CURRENCY!
  income: Float
  createdAt: DateTime!
  updatedAt: DateTime!
}

type PricingSubscriptionPayload {
  mutation: MutationType!
  node: Pricing
  updatedFields: [String!]
  previousValues: PricingPreviousValues
}

input PricingSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: PricingWhereInput
  AND: [PricingSubscriptionWhereInput!]
  OR: [PricingSubscriptionWhereInput!]
  NOT: [PricingSubscriptionWhereInput!]
}

input PricingUpdateInput {
  House: HouseUpdateOneRequiredWithoutPricingInput
  basePrice: Float
  highestPrice: Float
  currency: CURRENCY
  income: Float
}

input PricingUpdateManyMutationInput {
  basePrice: Float
  highestPrice: Float
  currency: CURRENCY
  income: Float
}

input PricingUpdateOneRequiredWithoutHouseInput {
  create: PricingCreateWithoutHouseInput
  update: PricingUpdateWithoutHouseDataInput
  upsert: PricingUpsertWithoutHouseInput
  connect: PricingWhereUniqueInput
}

input PricingUpdateWithoutHouseDataInput {
  basePrice: Float
  highestPrice: Float
  currency: CURRENCY
  income: Float
}

input PricingUpsertWithoutHouseInput {
  update: PricingUpdateWithoutHouseDataInput!
  create: PricingCreateWithoutHouseInput!
}

input PricingWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  House: HouseWhereInput
  basePrice: Float
  basePrice_not: Float
  basePrice_in: [Float!]
  basePrice_not_in: [Float!]
  basePrice_lt: Float
  basePrice_lte: Float
  basePrice_gt: Float
  basePrice_gte: Float
  highestPrice: Float
  highestPrice_not: Float
  highestPrice_in: [Float!]
  highestPrice_not_in: [Float!]
  highestPrice_lt: Float
  highestPrice_lte: Float
  highestPrice_gt: Float
  highestPrice_gte: Float
  currency: CURRENCY
  currency_not: CURRENCY
  currency_in: [CURRENCY!]
  currency_not_in: [CURRENCY!]
  income: Float
  income_not: Float
  income_in: [Float!]
  income_not_in: [Float!]
  income_lt: Float
  income_lte: Float
  income_gt: Float
  income_gte: Float
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [PricingWhereInput!]
  OR: [PricingWhereInput!]
  NOT: [PricingWhereInput!]
}

input PricingWhereUniqueInput {
  id: ID
}

type Query {
  amenities(where: AmenitiesWhereUniqueInput!): Amenities
  amenitieses(where: AmenitiesWhereInput, orderBy: AmenitiesOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Amenities]!
  amenitiesesConnection(where: AmenitiesWhereInput, orderBy: AmenitiesOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): AmenitiesConnection!
  booking(where: BookingWhereUniqueInput!): Booking
  bookings(where: BookingWhereInput, orderBy: BookingOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Booking]!
  bookingsConnection(where: BookingWhereInput, orderBy: BookingOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): BookingConnection!
  city(where: CityWhereUniqueInput!): City
  cities(where: CityWhereInput, orderBy: CityOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [City]!
  citiesConnection(where: CityWhereInput, orderBy: CityOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): CityConnection!
  commune(where: CommuneWhereUniqueInput!): Commune
  communes(where: CommuneWhereInput, orderBy: CommuneOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Commune]!
  communesConnection(where: CommuneWhereInput, orderBy: CommuneOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): CommuneConnection!
  country(where: CountryWhereUniqueInput!): Country
  countries(where: CountryWhereInput, orderBy: CountryOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Country]!
  countriesConnection(where: CountryWhereInput, orderBy: CountryOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): CountryConnection!
  creditCardInformation(where: CreditCardInformationWhereUniqueInput!): CreditCardInformation
  creditCardInformations(where: CreditCardInformationWhereInput, orderBy: CreditCardInformationOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [CreditCardInformation]!
  creditCardInformationsConnection(where: CreditCardInformationWhereInput, orderBy: CreditCardInformationOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): CreditCardInformationConnection!
  house(where: HouseWhereUniqueInput!): House
  houses(where: HouseWhereInput, orderBy: HouseOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [House]!
  housesConnection(where: HouseWhereInput, orderBy: HouseOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): HouseConnection!
  houseFavorited(where: House_FavoritedWhereUniqueInput!): House_Favorited
  houseFavoriteds(where: House_FavoritedWhereInput, orderBy: House_FavoritedOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [House_Favorited]!
  houseFavoritedsConnection(where: House_FavoritedWhereInput, orderBy: House_FavoritedOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): House_FavoritedConnection!
  location(where: LocationWhereUniqueInput!): Location
  locations(where: LocationWhereInput, orderBy: LocationOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Location]!
  locationsConnection(where: LocationWhereInput, orderBy: LocationOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): LocationConnection!
  negotiation(where: NegotiationWhereUniqueInput!): Negotiation
  negotiations(where: NegotiationWhereInput, orderBy: NegotiationOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Negotiation]!
  negotiationsConnection(where: NegotiationWhereInput, orderBy: NegotiationOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): NegotiationConnection!
  notification(where: NotificationWhereUniqueInput!): Notification
  notifications(where: NotificationWhereInput, orderBy: NotificationOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Notification]!
  notificationsConnection(where: NotificationWhereInput, orderBy: NotificationOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): NotificationConnection!
  paymentAccount(where: PaymentAccountWhereUniqueInput!): PaymentAccount
  paymentAccounts(where: PaymentAccountWhereInput, orderBy: PaymentAccountOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [PaymentAccount]!
  paymentAccountsConnection(where: PaymentAccountWhereInput, orderBy: PaymentAccountOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): PaymentAccountConnection!
  paymentHouse(where: PaymentHouseWhereUniqueInput!): PaymentHouse
  paymentHouses(where: PaymentHouseWhereInput, orderBy: PaymentHouseOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [PaymentHouse]!
  paymentHousesConnection(where: PaymentHouseWhereInput, orderBy: PaymentHouseOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): PaymentHouseConnection!
  paymentLanlordInfo(where: PaymentLanlordInfoWhereUniqueInput!): PaymentLanlordInfo
  paymentLanlordInfoes(where: PaymentLanlordInfoWhereInput, orderBy: PaymentLanlordInfoOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [PaymentLanlordInfo]!
  paymentLanlordInfoesConnection(where: PaymentLanlordInfoWhereInput, orderBy: PaymentLanlordInfoOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): PaymentLanlordInfoConnection!
  paypalInformation(where: PaypalInformationWhereUniqueInput!): PaypalInformation
  paypalInformations(where: PaypalInformationWhereInput, orderBy: PaypalInformationOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [PaypalInformation]!
  paypalInformationsConnection(where: PaypalInformationWhereInput, orderBy: PaypalInformationOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): PaypalInformationConnection!
  picture(where: PictureWhereUniqueInput!): Picture
  pictures(where: PictureWhereInput, orderBy: PictureOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Picture]!
  picturesConnection(where: PictureWhereInput, orderBy: PictureOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): PictureConnection!
  pricing(where: PricingWhereUniqueInput!): Pricing
  pricings(where: PricingWhereInput, orderBy: PricingOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Pricing]!
  pricingsConnection(where: PricingWhereInput, orderBy: PricingOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): PricingConnection!
  review(where: ReviewWhereUniqueInput!): Review
  reviews(where: ReviewWhereInput, orderBy: ReviewOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Review]!
  reviewsConnection(where: ReviewWhereInput, orderBy: ReviewOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): ReviewConnection!
  room(where: RoomWhereUniqueInput!): Room
  rooms(where: RoomWhereInput, orderBy: RoomOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Room]!
  roomsConnection(where: RoomWhereInput, orderBy: RoomOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): RoomConnection!
  state(where: StateWhereUniqueInput!): State
  states(where: StateWhereInput, orderBy: StateOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [State]!
  statesConnection(where: StateWhereInput, orderBy: StateOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): StateConnection!
  user(where: UserWhereUniqueInput!): User
  users(where: UserWhereInput, orderBy: UserOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [User]!
  usersConnection(where: UserWhereInput, orderBy: UserOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): UserConnection!
  video(where: VideoWhereUniqueInput!): Video
  videos(where: VideoWhereInput, orderBy: VideoOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Video]!
  videosConnection(where: VideoWhereInput, orderBy: VideoOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): VideoConnection!
  views(where: ViewsWhereUniqueInput!): Views
  viewses(where: ViewsWhereInput, orderBy: ViewsOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Views]!
  viewsesConnection(where: ViewsWhereInput, orderBy: ViewsOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): ViewsConnection!
  node(id: ID!): Node
}

type Review {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  text: String!
  stars: Int!
  accuracy: Int!
  location: Int!
  checkIn: Int!
  value: Int!
  communication: Int!
  House: House!
}

type ReviewConnection {
  pageInfo: PageInfo!
  edges: [ReviewEdge]!
  aggregate: AggregateReview!
}

input ReviewCreateInput {
  id: ID
  text: String!
  stars: Int!
  accuracy: Int!
  location: Int!
  checkIn: Int!
  value: Int!
  communication: Int!
  House: HouseCreateOneWithoutReviewsInput!
}

input ReviewCreateManyWithoutHouseInput {
  create: [ReviewCreateWithoutHouseInput!]
  connect: [ReviewWhereUniqueInput!]
}

input ReviewCreateWithoutHouseInput {
  id: ID
  text: String!
  stars: Int!
  accuracy: Int!
  location: Int!
  checkIn: Int!
  value: Int!
  communication: Int!
}

type ReviewEdge {
  node: Review!
  cursor: String!
}

enum ReviewOrderByInput {
  id_ASC
  id_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
  text_ASC
  text_DESC
  stars_ASC
  stars_DESC
  accuracy_ASC
  accuracy_DESC
  location_ASC
  location_DESC
  checkIn_ASC
  checkIn_DESC
  value_ASC
  value_DESC
  communication_ASC
  communication_DESC
}

type ReviewPreviousValues {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  text: String!
  stars: Int!
  accuracy: Int!
  location: Int!
  checkIn: Int!
  value: Int!
  communication: Int!
}

input ReviewScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  text: String
  text_not: String
  text_in: [String!]
  text_not_in: [String!]
  text_lt: String
  text_lte: String
  text_gt: String
  text_gte: String
  text_contains: String
  text_not_contains: String
  text_starts_with: String
  text_not_starts_with: String
  text_ends_with: String
  text_not_ends_with: String
  stars: Int
  stars_not: Int
  stars_in: [Int!]
  stars_not_in: [Int!]
  stars_lt: Int
  stars_lte: Int
  stars_gt: Int
  stars_gte: Int
  accuracy: Int
  accuracy_not: Int
  accuracy_in: [Int!]
  accuracy_not_in: [Int!]
  accuracy_lt: Int
  accuracy_lte: Int
  accuracy_gt: Int
  accuracy_gte: Int
  location: Int
  location_not: Int
  location_in: [Int!]
  location_not_in: [Int!]
  location_lt: Int
  location_lte: Int
  location_gt: Int
  location_gte: Int
  checkIn: Int
  checkIn_not: Int
  checkIn_in: [Int!]
  checkIn_not_in: [Int!]
  checkIn_lt: Int
  checkIn_lte: Int
  checkIn_gt: Int
  checkIn_gte: Int
  value: Int
  value_not: Int
  value_in: [Int!]
  value_not_in: [Int!]
  value_lt: Int
  value_lte: Int
  value_gt: Int
  value_gte: Int
  communication: Int
  communication_not: Int
  communication_in: [Int!]
  communication_not_in: [Int!]
  communication_lt: Int
  communication_lte: Int
  communication_gt: Int
  communication_gte: Int
  AND: [ReviewScalarWhereInput!]
  OR: [ReviewScalarWhereInput!]
  NOT: [ReviewScalarWhereInput!]
}

type ReviewSubscriptionPayload {
  mutation: MutationType!
  node: Review
  updatedFields: [String!]
  previousValues: ReviewPreviousValues
}

input ReviewSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: ReviewWhereInput
  AND: [ReviewSubscriptionWhereInput!]
  OR: [ReviewSubscriptionWhereInput!]
  NOT: [ReviewSubscriptionWhereInput!]
}

input ReviewUpdateInput {
  text: String
  stars: Int
  accuracy: Int
  location: Int
  checkIn: Int
  value: Int
  communication: Int
  House: HouseUpdateOneRequiredWithoutReviewsInput
}

input ReviewUpdateManyDataInput {
  text: String
  stars: Int
  accuracy: Int
  location: Int
  checkIn: Int
  value: Int
  communication: Int
}

input ReviewUpdateManyMutationInput {
  text: String
  stars: Int
  accuracy: Int
  location: Int
  checkIn: Int
  value: Int
  communication: Int
}

input ReviewUpdateManyWithoutHouseInput {
  create: [ReviewCreateWithoutHouseInput!]
  delete: [ReviewWhereUniqueInput!]
  connect: [ReviewWhereUniqueInput!]
  set: [ReviewWhereUniqueInput!]
  disconnect: [ReviewWhereUniqueInput!]
  update: [ReviewUpdateWithWhereUniqueWithoutHouseInput!]
  upsert: [ReviewUpsertWithWhereUniqueWithoutHouseInput!]
  deleteMany: [ReviewScalarWhereInput!]
  updateMany: [ReviewUpdateManyWithWhereNestedInput!]
}

input ReviewUpdateManyWithWhereNestedInput {
  where: ReviewScalarWhereInput!
  data: ReviewUpdateManyDataInput!
}

input ReviewUpdateWithoutHouseDataInput {
  text: String
  stars: Int
  accuracy: Int
  location: Int
  checkIn: Int
  value: Int
  communication: Int
}

input ReviewUpdateWithWhereUniqueWithoutHouseInput {
  where: ReviewWhereUniqueInput!
  data: ReviewUpdateWithoutHouseDataInput!
}

input ReviewUpsertWithWhereUniqueWithoutHouseInput {
  where: ReviewWhereUniqueInput!
  update: ReviewUpdateWithoutHouseDataInput!
  create: ReviewCreateWithoutHouseInput!
}

input ReviewWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  text: String
  text_not: String
  text_in: [String!]
  text_not_in: [String!]
  text_lt: String
  text_lte: String
  text_gt: String
  text_gte: String
  text_contains: String
  text_not_contains: String
  text_starts_with: String
  text_not_starts_with: String
  text_ends_with: String
  text_not_ends_with: String
  stars: Int
  stars_not: Int
  stars_in: [Int!]
  stars_not_in: [Int!]
  stars_lt: Int
  stars_lte: Int
  stars_gt: Int
  stars_gte: Int
  accuracy: Int
  accuracy_not: Int
  accuracy_in: [Int!]
  accuracy_not_in: [Int!]
  accuracy_lt: Int
  accuracy_lte: Int
  accuracy_gt: Int
  accuracy_gte: Int
  location: Int
  location_not: Int
  location_in: [Int!]
  location_not_in: [Int!]
  location_lt: Int
  location_lte: Int
  location_gt: Int
  location_gte: Int
  checkIn: Int
  checkIn_not: Int
  checkIn_in: [Int!]
  checkIn_not_in: [Int!]
  checkIn_lt: Int
  checkIn_lte: Int
  checkIn_gt: Int
  checkIn_gte: Int
  value: Int
  value_not: Int
  value_in: [Int!]
  value_not_in: [Int!]
  value_lt: Int
  value_lte: Int
  value_gt: Int
  value_gte: Int
  communication: Int
  communication_not: Int
  communication_in: [Int!]
  communication_not_in: [Int!]
  communication_lt: Int
  communication_lte: Int
  communication_gt: Int
  communication_gte: Int
  House: HouseWhereInput
  AND: [ReviewWhereInput!]
  OR: [ReviewWhereInput!]
  NOT: [ReviewWhereInput!]
}

input ReviewWhereUniqueInput {
  id: ID
}

type Room {
  id: ID!
  label: ROOM_LABELS!
  house: House!
  picture_previews(where: PictureWhereInput, orderBy: PictureOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Picture!]
  video_previews(where: VideoWhereInput, orderBy: VideoOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Video!]
  createdAt: DateTime!
  updatedAt: DateTime!
}

enum ROOM_LABELS {
  LIVINGROOM
  DINIGROOM
  BEDROOM
  BATHROOM
}

type RoomConnection {
  pageInfo: PageInfo!
  edges: [RoomEdge]!
  aggregate: AggregateRoom!
}

input RoomCreateInput {
  id: ID
  label: ROOM_LABELS!
  house: HouseCreateOneWithoutRoomsInput!
  picture_previews: PictureCreateManyInput
  video_previews: VideoCreateManyInput
}

input RoomCreateManyWithoutHouseInput {
  create: [RoomCreateWithoutHouseInput!]
  connect: [RoomWhereUniqueInput!]
}

input RoomCreateWithoutHouseInput {
  id: ID
  label: ROOM_LABELS!
  picture_previews: PictureCreateManyInput
  video_previews: VideoCreateManyInput
}

type RoomEdge {
  node: Room!
  cursor: String!
}

enum RoomOrderByInput {
  id_ASC
  id_DESC
  label_ASC
  label_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type RoomPreviousValues {
  id: ID!
  label: ROOM_LABELS!
  createdAt: DateTime!
  updatedAt: DateTime!
}

input RoomScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  label: ROOM_LABELS
  label_not: ROOM_LABELS
  label_in: [ROOM_LABELS!]
  label_not_in: [ROOM_LABELS!]
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [RoomScalarWhereInput!]
  OR: [RoomScalarWhereInput!]
  NOT: [RoomScalarWhereInput!]
}

type RoomSubscriptionPayload {
  mutation: MutationType!
  node: Room
  updatedFields: [String!]
  previousValues: RoomPreviousValues
}

input RoomSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: RoomWhereInput
  AND: [RoomSubscriptionWhereInput!]
  OR: [RoomSubscriptionWhereInput!]
  NOT: [RoomSubscriptionWhereInput!]
}

input RoomUpdateInput {
  label: ROOM_LABELS
  house: HouseUpdateOneRequiredWithoutRoomsInput
  picture_previews: PictureUpdateManyInput
  video_previews: VideoUpdateManyInput
}

input RoomUpdateManyDataInput {
  label: ROOM_LABELS
}

input RoomUpdateManyMutationInput {
  label: ROOM_LABELS
}

input RoomUpdateManyWithoutHouseInput {
  create: [RoomCreateWithoutHouseInput!]
  delete: [RoomWhereUniqueInput!]
  connect: [RoomWhereUniqueInput!]
  set: [RoomWhereUniqueInput!]
  disconnect: [RoomWhereUniqueInput!]
  update: [RoomUpdateWithWhereUniqueWithoutHouseInput!]
  upsert: [RoomUpsertWithWhereUniqueWithoutHouseInput!]
  deleteMany: [RoomScalarWhereInput!]
  updateMany: [RoomUpdateManyWithWhereNestedInput!]
}

input RoomUpdateManyWithWhereNestedInput {
  where: RoomScalarWhereInput!
  data: RoomUpdateManyDataInput!
}

input RoomUpdateWithoutHouseDataInput {
  label: ROOM_LABELS
  picture_previews: PictureUpdateManyInput
  video_previews: VideoUpdateManyInput
}

input RoomUpdateWithWhereUniqueWithoutHouseInput {
  where: RoomWhereUniqueInput!
  data: RoomUpdateWithoutHouseDataInput!
}

input RoomUpsertWithWhereUniqueWithoutHouseInput {
  where: RoomWhereUniqueInput!
  update: RoomUpdateWithoutHouseDataInput!
  create: RoomCreateWithoutHouseInput!
}

input RoomWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  label: ROOM_LABELS
  label_not: ROOM_LABELS
  label_in: [ROOM_LABELS!]
  label_not_in: [ROOM_LABELS!]
  house: HouseWhereInput
  picture_previews_every: PictureWhereInput
  picture_previews_some: PictureWhereInput
  picture_previews_none: PictureWhereInput
  video_previews_every: VideoWhereInput
  video_previews_some: VideoWhereInput
  video_previews_none: VideoWhereInput
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [RoomWhereInput!]
  OR: [RoomWhereInput!]
  NOT: [RoomWhereInput!]
}

input RoomWhereUniqueInput {
  id: ID
}

type State {
  id: ID!
  name: String!
  rank: Int
  country: Country!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type StateConnection {
  pageInfo: PageInfo!
  edges: [StateEdge]!
  aggregate: AggregateState!
}

input StateCreateInput {
  id: ID
  name: String!
  rank: Int
  country: CountryCreateOneInput!
}

input StateCreateOneInput {
  create: StateCreateInput
  connect: StateWhereUniqueInput
}

type StateEdge {
  node: State!
  cursor: String!
}

enum StateOrderByInput {
  id_ASC
  id_DESC
  name_ASC
  name_DESC
  rank_ASC
  rank_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type StatePreviousValues {
  id: ID!
  name: String!
  rank: Int
  createdAt: DateTime!
  updatedAt: DateTime!
}

type StateSubscriptionPayload {
  mutation: MutationType!
  node: State
  updatedFields: [String!]
  previousValues: StatePreviousValues
}

input StateSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: StateWhereInput
  AND: [StateSubscriptionWhereInput!]
  OR: [StateSubscriptionWhereInput!]
  NOT: [StateSubscriptionWhereInput!]
}

input StateUpdateDataInput {
  name: String
  rank: Int
  country: CountryUpdateOneRequiredInput
}

input StateUpdateInput {
  name: String
  rank: Int
  country: CountryUpdateOneRequiredInput
}

input StateUpdateManyMutationInput {
  name: String
  rank: Int
}

input StateUpdateOneRequiredInput {
  create: StateCreateInput
  update: StateUpdateDataInput
  upsert: StateUpsertNestedInput
  connect: StateWhereUniqueInput
}

input StateUpsertNestedInput {
  update: StateUpdateDataInput!
  create: StateCreateInput!
}

input StateWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  rank: Int
  rank_not: Int
  rank_in: [Int!]
  rank_not_in: [Int!]
  rank_lt: Int
  rank_lte: Int
  rank_gt: Int
  rank_gte: Int
  country: CountryWhereInput
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [StateWhereInput!]
  OR: [StateWhereInput!]
  NOT: [StateWhereInput!]
}

input StateWhereUniqueInput {
  id: ID
}

type Subscription {
  amenities(where: AmenitiesSubscriptionWhereInput): AmenitiesSubscriptionPayload
  booking(where: BookingSubscriptionWhereInput): BookingSubscriptionPayload
  city(where: CitySubscriptionWhereInput): CitySubscriptionPayload
  commune(where: CommuneSubscriptionWhereInput): CommuneSubscriptionPayload
  country(where: CountrySubscriptionWhereInput): CountrySubscriptionPayload
  creditCardInformation(where: CreditCardInformationSubscriptionWhereInput): CreditCardInformationSubscriptionPayload
  house(where: HouseSubscriptionWhereInput): HouseSubscriptionPayload
  houseFavorited(where: House_FavoritedSubscriptionWhereInput): House_FavoritedSubscriptionPayload
  location(where: LocationSubscriptionWhereInput): LocationSubscriptionPayload
  negotiation(where: NegotiationSubscriptionWhereInput): NegotiationSubscriptionPayload
  notification(where: NotificationSubscriptionWhereInput): NotificationSubscriptionPayload
  paymentAccount(where: PaymentAccountSubscriptionWhereInput): PaymentAccountSubscriptionPayload
  paymentHouse(where: PaymentHouseSubscriptionWhereInput): PaymentHouseSubscriptionPayload
  paymentLanlordInfo(where: PaymentLanlordInfoSubscriptionWhereInput): PaymentLanlordInfoSubscriptionPayload
  paypalInformation(where: PaypalInformationSubscriptionWhereInput): PaypalInformationSubscriptionPayload
  picture(where: PictureSubscriptionWhereInput): PictureSubscriptionPayload
  pricing(where: PricingSubscriptionWhereInput): PricingSubscriptionPayload
  review(where: ReviewSubscriptionWhereInput): ReviewSubscriptionPayload
  room(where: RoomSubscriptionWhereInput): RoomSubscriptionPayload
  state(where: StateSubscriptionWhereInput): StateSubscriptionPayload
  user(where: UserSubscriptionWhereInput): UserSubscriptionPayload
  video(where: VideoSubscriptionWhereInput): VideoSubscriptionPayload
  views(where: ViewsSubscriptionWhereInput): ViewsSubscriptionPayload
}

type User {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  status: Boolean
  facebookUserId: String
  firstName: String!
  lastName: String!
  email: String
  password: String
  resetToken: String
  resetTokenExpiry: String
  phone1: String
  phone2: String
  primaryPhone: Int!
  responseTime: Int
  isSuperHost: Boolean!
  ownedHouses(where: HouseWhereInput, orderBy: HouseOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [House!]
  location: Location
  bookings(where: BookingWhereInput, orderBy: BookingOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Booking!]
  paidContacts(where: PaymentLanlordInfoWhereInput, orderBy: PaymentLanlordInfoOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [PaymentLanlordInfo!]
  notifications(where: NotificationWhereInput, orderBy: NotificationOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Notification!]
  profilePicture: Picture
  permissions: [Permission!]!
}

type UserConnection {
  pageInfo: PageInfo!
  edges: [UserEdge]!
  aggregate: AggregateUser!
}

input UserCreateInput {
  id: ID
  status: Boolean
  facebookUserId: String
  firstName: String!
  lastName: String!
  email: String
  password: String
  resetToken: String
  resetTokenExpiry: String
  phone1: String
  phone2: String
  primaryPhone: Int
  responseTime: Int
  isSuperHost: Boolean
  ownedHouses: HouseCreateManyWithoutHostInput
  location: LocationCreateOneInput
  bookings: BookingCreateManyWithoutBookeeInput
  paidContacts: PaymentLanlordInfoCreateManyWithoutClientInput
  notifications: NotificationCreateManyWithoutUserInput
  profilePicture: PictureCreateOneInput
  permissions: UserCreatepermissionsInput
}

input UserCreateManyInput {
  create: [UserCreateInput!]
  connect: [UserWhereUniqueInput!]
}

input UserCreateOneInput {
  create: UserCreateInput
  connect: UserWhereUniqueInput
}

input UserCreateOneWithoutBookingsInput {
  create: UserCreateWithoutBookingsInput
  connect: UserWhereUniqueInput
}

input UserCreateOneWithoutNotificationsInput {
  create: UserCreateWithoutNotificationsInput
  connect: UserWhereUniqueInput
}

input UserCreateOneWithoutOwnedHousesInput {
  create: UserCreateWithoutOwnedHousesInput
  connect: UserWhereUniqueInput
}

input UserCreateOneWithoutPaidContactsInput {
  create: UserCreateWithoutPaidContactsInput
  connect: UserWhereUniqueInput
}

input UserCreatepermissionsInput {
  set: [Permission!]
}

input UserCreateWithoutBookingsInput {
  id: ID
  status: Boolean
  facebookUserId: String
  firstName: String!
  lastName: String!
  email: String
  password: String
  resetToken: String
  resetTokenExpiry: String
  phone1: String
  phone2: String
  primaryPhone: Int
  responseTime: Int
  isSuperHost: Boolean
  ownedHouses: HouseCreateManyWithoutHostInput
  location: LocationCreateOneInput
  paidContacts: PaymentLanlordInfoCreateManyWithoutClientInput
  notifications: NotificationCreateManyWithoutUserInput
  profilePicture: PictureCreateOneInput
  permissions: UserCreatepermissionsInput
}

input UserCreateWithoutNotificationsInput {
  id: ID
  status: Boolean
  facebookUserId: String
  firstName: String!
  lastName: String!
  email: String
  password: String
  resetToken: String
  resetTokenExpiry: String
  phone1: String
  phone2: String
  primaryPhone: Int
  responseTime: Int
  isSuperHost: Boolean
  ownedHouses: HouseCreateManyWithoutHostInput
  location: LocationCreateOneInput
  bookings: BookingCreateManyWithoutBookeeInput
  paidContacts: PaymentLanlordInfoCreateManyWithoutClientInput
  profilePicture: PictureCreateOneInput
  permissions: UserCreatepermissionsInput
}

input UserCreateWithoutOwnedHousesInput {
  id: ID
  status: Boolean
  facebookUserId: String
  firstName: String!
  lastName: String!
  email: String
  password: String
  resetToken: String
  resetTokenExpiry: String
  phone1: String
  phone2: String
  primaryPhone: Int
  responseTime: Int
  isSuperHost: Boolean
  location: LocationCreateOneInput
  bookings: BookingCreateManyWithoutBookeeInput
  paidContacts: PaymentLanlordInfoCreateManyWithoutClientInput
  notifications: NotificationCreateManyWithoutUserInput
  profilePicture: PictureCreateOneInput
  permissions: UserCreatepermissionsInput
}

input UserCreateWithoutPaidContactsInput {
  id: ID
  status: Boolean
  facebookUserId: String
  firstName: String!
  lastName: String!
  email: String
  password: String
  resetToken: String
  resetTokenExpiry: String
  phone1: String
  phone2: String
  primaryPhone: Int
  responseTime: Int
  isSuperHost: Boolean
  ownedHouses: HouseCreateManyWithoutHostInput
  location: LocationCreateOneInput
  bookings: BookingCreateManyWithoutBookeeInput
  notifications: NotificationCreateManyWithoutUserInput
  profilePicture: PictureCreateOneInput
  permissions: UserCreatepermissionsInput
}

type UserEdge {
  node: User!
  cursor: String!
}

enum UserOrderByInput {
  id_ASC
  id_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
  status_ASC
  status_DESC
  facebookUserId_ASC
  facebookUserId_DESC
  firstName_ASC
  firstName_DESC
  lastName_ASC
  lastName_DESC
  email_ASC
  email_DESC
  password_ASC
  password_DESC
  resetToken_ASC
  resetToken_DESC
  resetTokenExpiry_ASC
  resetTokenExpiry_DESC
  phone1_ASC
  phone1_DESC
  phone2_ASC
  phone2_DESC
  primaryPhone_ASC
  primaryPhone_DESC
  responseTime_ASC
  responseTime_DESC
  isSuperHost_ASC
  isSuperHost_DESC
}

type UserPreviousValues {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  status: Boolean
  facebookUserId: String
  firstName: String!
  lastName: String!
  email: String
  password: String
  resetToken: String
  resetTokenExpiry: String
  phone1: String
  phone2: String
  primaryPhone: Int!
  responseTime: Int
  isSuperHost: Boolean!
  permissions: [Permission!]!
}

input UserScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  status: Boolean
  status_not: Boolean
  facebookUserId: String
  facebookUserId_not: String
  facebookUserId_in: [String!]
  facebookUserId_not_in: [String!]
  facebookUserId_lt: String
  facebookUserId_lte: String
  facebookUserId_gt: String
  facebookUserId_gte: String
  facebookUserId_contains: String
  facebookUserId_not_contains: String
  facebookUserId_starts_with: String
  facebookUserId_not_starts_with: String
  facebookUserId_ends_with: String
  facebookUserId_not_ends_with: String
  firstName: String
  firstName_not: String
  firstName_in: [String!]
  firstName_not_in: [String!]
  firstName_lt: String
  firstName_lte: String
  firstName_gt: String
  firstName_gte: String
  firstName_contains: String
  firstName_not_contains: String
  firstName_starts_with: String
  firstName_not_starts_with: String
  firstName_ends_with: String
  firstName_not_ends_with: String
  lastName: String
  lastName_not: String
  lastName_in: [String!]
  lastName_not_in: [String!]
  lastName_lt: String
  lastName_lte: String
  lastName_gt: String
  lastName_gte: String
  lastName_contains: String
  lastName_not_contains: String
  lastName_starts_with: String
  lastName_not_starts_with: String
  lastName_ends_with: String
  lastName_not_ends_with: String
  email: String
  email_not: String
  email_in: [String!]
  email_not_in: [String!]
  email_lt: String
  email_lte: String
  email_gt: String
  email_gte: String
  email_contains: String
  email_not_contains: String
  email_starts_with: String
  email_not_starts_with: String
  email_ends_with: String
  email_not_ends_with: String
  password: String
  password_not: String
  password_in: [String!]
  password_not_in: [String!]
  password_lt: String
  password_lte: String
  password_gt: String
  password_gte: String
  password_contains: String
  password_not_contains: String
  password_starts_with: String
  password_not_starts_with: String
  password_ends_with: String
  password_not_ends_with: String
  resetToken: String
  resetToken_not: String
  resetToken_in: [String!]
  resetToken_not_in: [String!]
  resetToken_lt: String
  resetToken_lte: String
  resetToken_gt: String
  resetToken_gte: String
  resetToken_contains: String
  resetToken_not_contains: String
  resetToken_starts_with: String
  resetToken_not_starts_with: String
  resetToken_ends_with: String
  resetToken_not_ends_with: String
  resetTokenExpiry: String
  resetTokenExpiry_not: String
  resetTokenExpiry_in: [String!]
  resetTokenExpiry_not_in: [String!]
  resetTokenExpiry_lt: String
  resetTokenExpiry_lte: String
  resetTokenExpiry_gt: String
  resetTokenExpiry_gte: String
  resetTokenExpiry_contains: String
  resetTokenExpiry_not_contains: String
  resetTokenExpiry_starts_with: String
  resetTokenExpiry_not_starts_with: String
  resetTokenExpiry_ends_with: String
  resetTokenExpiry_not_ends_with: String
  phone1: String
  phone1_not: String
  phone1_in: [String!]
  phone1_not_in: [String!]
  phone1_lt: String
  phone1_lte: String
  phone1_gt: String
  phone1_gte: String
  phone1_contains: String
  phone1_not_contains: String
  phone1_starts_with: String
  phone1_not_starts_with: String
  phone1_ends_with: String
  phone1_not_ends_with: String
  phone2: String
  phone2_not: String
  phone2_in: [String!]
  phone2_not_in: [String!]
  phone2_lt: String
  phone2_lte: String
  phone2_gt: String
  phone2_gte: String
  phone2_contains: String
  phone2_not_contains: String
  phone2_starts_with: String
  phone2_not_starts_with: String
  phone2_ends_with: String
  phone2_not_ends_with: String
  primaryPhone: Int
  primaryPhone_not: Int
  primaryPhone_in: [Int!]
  primaryPhone_not_in: [Int!]
  primaryPhone_lt: Int
  primaryPhone_lte: Int
  primaryPhone_gt: Int
  primaryPhone_gte: Int
  responseTime: Int
  responseTime_not: Int
  responseTime_in: [Int!]
  responseTime_not_in: [Int!]
  responseTime_lt: Int
  responseTime_lte: Int
  responseTime_gt: Int
  responseTime_gte: Int
  isSuperHost: Boolean
  isSuperHost_not: Boolean
  AND: [UserScalarWhereInput!]
  OR: [UserScalarWhereInput!]
  NOT: [UserScalarWhereInput!]
}

type UserSubscriptionPayload {
  mutation: MutationType!
  node: User
  updatedFields: [String!]
  previousValues: UserPreviousValues
}

input UserSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: UserWhereInput
  AND: [UserSubscriptionWhereInput!]
  OR: [UserSubscriptionWhereInput!]
  NOT: [UserSubscriptionWhereInput!]
}

input UserUpdateDataInput {
  status: Boolean
  facebookUserId: String
  firstName: String
  lastName: String
  email: String
  password: String
  resetToken: String
  resetTokenExpiry: String
  phone1: String
  phone2: String
  primaryPhone: Int
  responseTime: Int
  isSuperHost: Boolean
  ownedHouses: HouseUpdateManyWithoutHostInput
  location: LocationUpdateOneInput
  bookings: BookingUpdateManyWithoutBookeeInput
  paidContacts: PaymentLanlordInfoUpdateManyWithoutClientInput
  notifications: NotificationUpdateManyWithoutUserInput
  profilePicture: PictureUpdateOneInput
  permissions: UserUpdatepermissionsInput
}

input UserUpdateInput {
  status: Boolean
  facebookUserId: String
  firstName: String
  lastName: String
  email: String
  password: String
  resetToken: String
  resetTokenExpiry: String
  phone1: String
  phone2: String
  primaryPhone: Int
  responseTime: Int
  isSuperHost: Boolean
  ownedHouses: HouseUpdateManyWithoutHostInput
  location: LocationUpdateOneInput
  bookings: BookingUpdateManyWithoutBookeeInput
  paidContacts: PaymentLanlordInfoUpdateManyWithoutClientInput
  notifications: NotificationUpdateManyWithoutUserInput
  profilePicture: PictureUpdateOneInput
  permissions: UserUpdatepermissionsInput
}

input UserUpdateManyDataInput {
  status: Boolean
  facebookUserId: String
  firstName: String
  lastName: String
  email: String
  password: String
  resetToken: String
  resetTokenExpiry: String
  phone1: String
  phone2: String
  primaryPhone: Int
  responseTime: Int
  isSuperHost: Boolean
  permissions: UserUpdatepermissionsInput
}

input UserUpdateManyInput {
  create: [UserCreateInput!]
  update: [UserUpdateWithWhereUniqueNestedInput!]
  upsert: [UserUpsertWithWhereUniqueNestedInput!]
  delete: [UserWhereUniqueInput!]
  connect: [UserWhereUniqueInput!]
  set: [UserWhereUniqueInput!]
  disconnect: [UserWhereUniqueInput!]
  deleteMany: [UserScalarWhereInput!]
  updateMany: [UserUpdateManyWithWhereNestedInput!]
}

input UserUpdateManyMutationInput {
  status: Boolean
  facebookUserId: String
  firstName: String
  lastName: String
  email: String
  password: String
  resetToken: String
  resetTokenExpiry: String
  phone1: String
  phone2: String
  primaryPhone: Int
  responseTime: Int
  isSuperHost: Boolean
  permissions: UserUpdatepermissionsInput
}

input UserUpdateManyWithWhereNestedInput {
  where: UserScalarWhereInput!
  data: UserUpdateManyDataInput!
}

input UserUpdateOneRequiredInput {
  create: UserCreateInput
  update: UserUpdateDataInput
  upsert: UserUpsertNestedInput
  connect: UserWhereUniqueInput
}

input UserUpdateOneRequiredWithoutBookingsInput {
  create: UserCreateWithoutBookingsInput
  update: UserUpdateWithoutBookingsDataInput
  upsert: UserUpsertWithoutBookingsInput
  connect: UserWhereUniqueInput
}

input UserUpdateOneRequiredWithoutNotificationsInput {
  create: UserCreateWithoutNotificationsInput
  update: UserUpdateWithoutNotificationsDataInput
  upsert: UserUpsertWithoutNotificationsInput
  connect: UserWhereUniqueInput
}

input UserUpdateOneRequiredWithoutOwnedHousesInput {
  create: UserCreateWithoutOwnedHousesInput
  update: UserUpdateWithoutOwnedHousesDataInput
  upsert: UserUpsertWithoutOwnedHousesInput
  connect: UserWhereUniqueInput
}

input UserUpdateOneRequiredWithoutPaidContactsInput {
  create: UserCreateWithoutPaidContactsInput
  update: UserUpdateWithoutPaidContactsDataInput
  upsert: UserUpsertWithoutPaidContactsInput
  connect: UserWhereUniqueInput
}

input UserUpdatepermissionsInput {
  set: [Permission!]
}

input UserUpdateWithoutBookingsDataInput {
  status: Boolean
  facebookUserId: String
  firstName: String
  lastName: String
  email: String
  password: String
  resetToken: String
  resetTokenExpiry: String
  phone1: String
  phone2: String
  primaryPhone: Int
  responseTime: Int
  isSuperHost: Boolean
  ownedHouses: HouseUpdateManyWithoutHostInput
  location: LocationUpdateOneInput
  paidContacts: PaymentLanlordInfoUpdateManyWithoutClientInput
  notifications: NotificationUpdateManyWithoutUserInput
  profilePicture: PictureUpdateOneInput
  permissions: UserUpdatepermissionsInput
}

input UserUpdateWithoutNotificationsDataInput {
  status: Boolean
  facebookUserId: String
  firstName: String
  lastName: String
  email: String
  password: String
  resetToken: String
  resetTokenExpiry: String
  phone1: String
  phone2: String
  primaryPhone: Int
  responseTime: Int
  isSuperHost: Boolean
  ownedHouses: HouseUpdateManyWithoutHostInput
  location: LocationUpdateOneInput
  bookings: BookingUpdateManyWithoutBookeeInput
  paidContacts: PaymentLanlordInfoUpdateManyWithoutClientInput
  profilePicture: PictureUpdateOneInput
  permissions: UserUpdatepermissionsInput
}

input UserUpdateWithoutOwnedHousesDataInput {
  status: Boolean
  facebookUserId: String
  firstName: String
  lastName: String
  email: String
  password: String
  resetToken: String
  resetTokenExpiry: String
  phone1: String
  phone2: String
  primaryPhone: Int
  responseTime: Int
  isSuperHost: Boolean
  location: LocationUpdateOneInput
  bookings: BookingUpdateManyWithoutBookeeInput
  paidContacts: PaymentLanlordInfoUpdateManyWithoutClientInput
  notifications: NotificationUpdateManyWithoutUserInput
  profilePicture: PictureUpdateOneInput
  permissions: UserUpdatepermissionsInput
}

input UserUpdateWithoutPaidContactsDataInput {
  status: Boolean
  facebookUserId: String
  firstName: String
  lastName: String
  email: String
  password: String
  resetToken: String
  resetTokenExpiry: String
  phone1: String
  phone2: String
  primaryPhone: Int
  responseTime: Int
  isSuperHost: Boolean
  ownedHouses: HouseUpdateManyWithoutHostInput
  location: LocationUpdateOneInput
  bookings: BookingUpdateManyWithoutBookeeInput
  notifications: NotificationUpdateManyWithoutUserInput
  profilePicture: PictureUpdateOneInput
  permissions: UserUpdatepermissionsInput
}

input UserUpdateWithWhereUniqueNestedInput {
  where: UserWhereUniqueInput!
  data: UserUpdateDataInput!
}

input UserUpsertNestedInput {
  update: UserUpdateDataInput!
  create: UserCreateInput!
}

input UserUpsertWithoutBookingsInput {
  update: UserUpdateWithoutBookingsDataInput!
  create: UserCreateWithoutBookingsInput!
}

input UserUpsertWithoutNotificationsInput {
  update: UserUpdateWithoutNotificationsDataInput!
  create: UserCreateWithoutNotificationsInput!
}

input UserUpsertWithoutOwnedHousesInput {
  update: UserUpdateWithoutOwnedHousesDataInput!
  create: UserCreateWithoutOwnedHousesInput!
}

input UserUpsertWithoutPaidContactsInput {
  update: UserUpdateWithoutPaidContactsDataInput!
  create: UserCreateWithoutPaidContactsInput!
}

input UserUpsertWithWhereUniqueNestedInput {
  where: UserWhereUniqueInput!
  update: UserUpdateDataInput!
  create: UserCreateInput!
}

input UserWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  status: Boolean
  status_not: Boolean
  facebookUserId: String
  facebookUserId_not: String
  facebookUserId_in: [String!]
  facebookUserId_not_in: [String!]
  facebookUserId_lt: String
  facebookUserId_lte: String
  facebookUserId_gt: String
  facebookUserId_gte: String
  facebookUserId_contains: String
  facebookUserId_not_contains: String
  facebookUserId_starts_with: String
  facebookUserId_not_starts_with: String
  facebookUserId_ends_with: String
  facebookUserId_not_ends_with: String
  firstName: String
  firstName_not: String
  firstName_in: [String!]
  firstName_not_in: [String!]
  firstName_lt: String
  firstName_lte: String
  firstName_gt: String
  firstName_gte: String
  firstName_contains: String
  firstName_not_contains: String
  firstName_starts_with: String
  firstName_not_starts_with: String
  firstName_ends_with: String
  firstName_not_ends_with: String
  lastName: String
  lastName_not: String
  lastName_in: [String!]
  lastName_not_in: [String!]
  lastName_lt: String
  lastName_lte: String
  lastName_gt: String
  lastName_gte: String
  lastName_contains: String
  lastName_not_contains: String
  lastName_starts_with: String
  lastName_not_starts_with: String
  lastName_ends_with: String
  lastName_not_ends_with: String
  email: String
  email_not: String
  email_in: [String!]
  email_not_in: [String!]
  email_lt: String
  email_lte: String
  email_gt: String
  email_gte: String
  email_contains: String
  email_not_contains: String
  email_starts_with: String
  email_not_starts_with: String
  email_ends_with: String
  email_not_ends_with: String
  password: String
  password_not: String
  password_in: [String!]
  password_not_in: [String!]
  password_lt: String
  password_lte: String
  password_gt: String
  password_gte: String
  password_contains: String
  password_not_contains: String
  password_starts_with: String
  password_not_starts_with: String
  password_ends_with: String
  password_not_ends_with: String
  resetToken: String
  resetToken_not: String
  resetToken_in: [String!]
  resetToken_not_in: [String!]
  resetToken_lt: String
  resetToken_lte: String
  resetToken_gt: String
  resetToken_gte: String
  resetToken_contains: String
  resetToken_not_contains: String
  resetToken_starts_with: String
  resetToken_not_starts_with: String
  resetToken_ends_with: String
  resetToken_not_ends_with: String
  resetTokenExpiry: String
  resetTokenExpiry_not: String
  resetTokenExpiry_in: [String!]
  resetTokenExpiry_not_in: [String!]
  resetTokenExpiry_lt: String
  resetTokenExpiry_lte: String
  resetTokenExpiry_gt: String
  resetTokenExpiry_gte: String
  resetTokenExpiry_contains: String
  resetTokenExpiry_not_contains: String
  resetTokenExpiry_starts_with: String
  resetTokenExpiry_not_starts_with: String
  resetTokenExpiry_ends_with: String
  resetTokenExpiry_not_ends_with: String
  phone1: String
  phone1_not: String
  phone1_in: [String!]
  phone1_not_in: [String!]
  phone1_lt: String
  phone1_lte: String
  phone1_gt: String
  phone1_gte: String
  phone1_contains: String
  phone1_not_contains: String
  phone1_starts_with: String
  phone1_not_starts_with: String
  phone1_ends_with: String
  phone1_not_ends_with: String
  phone2: String
  phone2_not: String
  phone2_in: [String!]
  phone2_not_in: [String!]
  phone2_lt: String
  phone2_lte: String
  phone2_gt: String
  phone2_gte: String
  phone2_contains: String
  phone2_not_contains: String
  phone2_starts_with: String
  phone2_not_starts_with: String
  phone2_ends_with: String
  phone2_not_ends_with: String
  primaryPhone: Int
  primaryPhone_not: Int
  primaryPhone_in: [Int!]
  primaryPhone_not_in: [Int!]
  primaryPhone_lt: Int
  primaryPhone_lte: Int
  primaryPhone_gt: Int
  primaryPhone_gte: Int
  responseTime: Int
  responseTime_not: Int
  responseTime_in: [Int!]
  responseTime_not_in: [Int!]
  responseTime_lt: Int
  responseTime_lte: Int
  responseTime_gt: Int
  responseTime_gte: Int
  isSuperHost: Boolean
  isSuperHost_not: Boolean
  ownedHouses_every: HouseWhereInput
  ownedHouses_some: HouseWhereInput
  ownedHouses_none: HouseWhereInput
  location: LocationWhereInput
  bookings_every: BookingWhereInput
  bookings_some: BookingWhereInput
  bookings_none: BookingWhereInput
  paidContacts_every: PaymentLanlordInfoWhereInput
  paidContacts_some: PaymentLanlordInfoWhereInput
  paidContacts_none: PaymentLanlordInfoWhereInput
  notifications_every: NotificationWhereInput
  notifications_some: NotificationWhereInput
  notifications_none: NotificationWhereInput
  profilePicture: PictureWhereInput
  AND: [UserWhereInput!]
  OR: [UserWhereInput!]
  NOT: [UserWhereInput!]
}

input UserWhereUniqueInput {
  id: ID
  facebookUserId: String
  email: String
}

type Video {
  id: ID!
  url: String!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type VideoConnection {
  pageInfo: PageInfo!
  edges: [VideoEdge]!
  aggregate: AggregateVideo!
}

input VideoCreateInput {
  id: ID
  url: String!
}

input VideoCreateManyInput {
  create: [VideoCreateInput!]
  connect: [VideoWhereUniqueInput!]
}

type VideoEdge {
  node: Video!
  cursor: String!
}

enum VideoOrderByInput {
  id_ASC
  id_DESC
  url_ASC
  url_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type VideoPreviousValues {
  id: ID!
  url: String!
  createdAt: DateTime!
  updatedAt: DateTime!
}

input VideoScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  url: String
  url_not: String
  url_in: [String!]
  url_not_in: [String!]
  url_lt: String
  url_lte: String
  url_gt: String
  url_gte: String
  url_contains: String
  url_not_contains: String
  url_starts_with: String
  url_not_starts_with: String
  url_ends_with: String
  url_not_ends_with: String
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [VideoScalarWhereInput!]
  OR: [VideoScalarWhereInput!]
  NOT: [VideoScalarWhereInput!]
}

type VideoSubscriptionPayload {
  mutation: MutationType!
  node: Video
  updatedFields: [String!]
  previousValues: VideoPreviousValues
}

input VideoSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: VideoWhereInput
  AND: [VideoSubscriptionWhereInput!]
  OR: [VideoSubscriptionWhereInput!]
  NOT: [VideoSubscriptionWhereInput!]
}

input VideoUpdateDataInput {
  url: String
}

input VideoUpdateInput {
  url: String
}

input VideoUpdateManyDataInput {
  url: String
}

input VideoUpdateManyInput {
  create: [VideoCreateInput!]
  update: [VideoUpdateWithWhereUniqueNestedInput!]
  upsert: [VideoUpsertWithWhereUniqueNestedInput!]
  delete: [VideoWhereUniqueInput!]
  connect: [VideoWhereUniqueInput!]
  set: [VideoWhereUniqueInput!]
  disconnect: [VideoWhereUniqueInput!]
  deleteMany: [VideoScalarWhereInput!]
  updateMany: [VideoUpdateManyWithWhereNestedInput!]
}

input VideoUpdateManyMutationInput {
  url: String
}

input VideoUpdateManyWithWhereNestedInput {
  where: VideoScalarWhereInput!
  data: VideoUpdateManyDataInput!
}

input VideoUpdateWithWhereUniqueNestedInput {
  where: VideoWhereUniqueInput!
  data: VideoUpdateDataInput!
}

input VideoUpsertWithWhereUniqueNestedInput {
  where: VideoWhereUniqueInput!
  update: VideoUpdateDataInput!
  create: VideoCreateInput!
}

input VideoWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  url: String
  url_not: String
  url_in: [String!]
  url_not_in: [String!]
  url_lt: String
  url_lte: String
  url_gt: String
  url_gte: String
  url_contains: String
  url_not_contains: String
  url_starts_with: String
  url_not_starts_with: String
  url_ends_with: String
  url_not_ends_with: String
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [VideoWhereInput!]
  OR: [VideoWhereInput!]
  NOT: [VideoWhereInput!]
}

input VideoWhereUniqueInput {
  id: ID
}

type Views {
  id: ID!
  lastWeek: Int!
  House: House!
  User(where: UserWhereInput, orderBy: UserOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [User!]
  createdAt: DateTime!
  updatedAt: DateTime!
}

type ViewsConnection {
  pageInfo: PageInfo!
  edges: [ViewsEdge]!
  aggregate: AggregateViews!
}

input ViewsCreateInput {
  id: ID
  lastWeek: Int!
  House: HouseCreateOneWithoutViewsInput!
  User: UserCreateManyInput
}

input ViewsCreateOneWithoutHouseInput {
  create: ViewsCreateWithoutHouseInput
  connect: ViewsWhereUniqueInput
}

input ViewsCreateWithoutHouseInput {
  id: ID
  lastWeek: Int!
  User: UserCreateManyInput
}

type ViewsEdge {
  node: Views!
  cursor: String!
}

enum ViewsOrderByInput {
  id_ASC
  id_DESC
  lastWeek_ASC
  lastWeek_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type ViewsPreviousValues {
  id: ID!
  lastWeek: Int!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type ViewsSubscriptionPayload {
  mutation: MutationType!
  node: Views
  updatedFields: [String!]
  previousValues: ViewsPreviousValues
}

input ViewsSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: ViewsWhereInput
  AND: [ViewsSubscriptionWhereInput!]
  OR: [ViewsSubscriptionWhereInput!]
  NOT: [ViewsSubscriptionWhereInput!]
}

input ViewsUpdateInput {
  lastWeek: Int
  House: HouseUpdateOneRequiredWithoutViewsInput
  User: UserUpdateManyInput
}

input ViewsUpdateManyMutationInput {
  lastWeek: Int
}

input ViewsUpdateOneWithoutHouseInput {
  create: ViewsCreateWithoutHouseInput
  update: ViewsUpdateWithoutHouseDataInput
  upsert: ViewsUpsertWithoutHouseInput
  delete: Boolean
  disconnect: Boolean
  connect: ViewsWhereUniqueInput
}

input ViewsUpdateWithoutHouseDataInput {
  lastWeek: Int
  User: UserUpdateManyInput
}

input ViewsUpsertWithoutHouseInput {
  update: ViewsUpdateWithoutHouseDataInput!
  create: ViewsCreateWithoutHouseInput!
}

input ViewsWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  lastWeek: Int
  lastWeek_not: Int
  lastWeek_in: [Int!]
  lastWeek_not_in: [Int!]
  lastWeek_lt: Int
  lastWeek_lte: Int
  lastWeek_gt: Int
  lastWeek_gte: Int
  House: HouseWhereInput
  User_every: UserWhereInput
  User_some: UserWhereInput
  User_none: UserWhereInput
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [ViewsWhereInput!]
  OR: [ViewsWhereInput!]
  NOT: [ViewsWhereInput!]
}

input ViewsWhereUniqueInput {
  id: ID
}
`